# tsconfig.json

```json
{ "compilerOptions": { "target": "ES2017", "lib": ["dom", "dom.iterable", "esnext"], "allowJs": true, "skipLibCheck": true, "strict": true, "noEmit": true, "esModuleInterop": true, "module": "esnext", "moduleResolution": "bundler", "resolveJsonModule": true, "isolatedModules": true, "jsx": "preserve", "incremental": true, "plugins": [ { "name": "next" } ], "paths": { "@/*": ["./src/*"] } }, "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx", ".next/types/**/*.ts"], "exclude": ["node_modules"] }
```

# tailwind.config.js

```js
/** @type {import('tailwindcss').Config} */ module.exports = { darkMode: 'class', content: [ './pages/**/*.{js,ts,jsx,tsx,mdx}', './components/**/*.{js,ts,jsx,tsx,mdx}', './app/**/*.{js,ts,jsx,tsx,mdx}', ], theme: { extend: { colors: { // Add any custom colors here }, animation: { 'spin-slow': 'spin 3s linear infinite', }, }, }, plugins: [], }
```

# postcss.config.mjs

```mjs
const config = { plugins: ["@tailwindcss/postcss"], }; export default config;
```

# package.json

```json
{ "name": "social-media-app", "version": "0.1.0", "private": true, "scripts": { "dev": "next dev", "build": "next build", "start": "next start", "lint": "next lint", "prisma:studio": "prisma studio", "prisma:generate": "prisma generate", "prisma:migrate": "prisma migrate dev", "prisma:seed": "node --import tsx prisma/seed.ts" }, "dependencies": { "@prisma/client": "^6.6.0", "@radix-ui/react-dialog": "^1.1.7", "@radix-ui/react-dropdown-menu": "^2.1.7", "bcrypt": "^5.1.1", "date-fns": "^4.1.0", "lucide-react": "^0.488.0", "next": "15.3.0", "next-auth": "^4.24.11", "react": "^19.0.0", "react-dom": "^19.0.0", "react-hook-form": "^7.55.0", "react-hot-toast": "^2.5.2", "react-intersection-observer": "^9.16.0", "recharts": "^2.15.2", "tsx": "^4.19.3", "zod": "^3.24.3" }, "devDependencies": { "@eslint/eslintrc": "^3", "@hookform/resolvers": "^5.0.1", "@tailwindcss/postcss": "^4", "@types/bcrypt": "^5.0.2", "@types/node": "^20", "@types/react": "^19", "@types/react-dom": "^19", "eslint": "^9", "eslint-config-next": "15.3.0", "eslint-config-prettier": "^10.1.2", "prisma": "^6.6.0", "tailwindcss": "^4", "typescript": "^5" } }
```

# next.config.ts

```ts
/** @type {import('next').NextConfig} */ const nextConfig = { images: { domains: [ 'lh3.googleusercontent.com', // Google profile images 'i.pravatar.cc', // Pravatar avatars (used in seed data) 'picsum.photos', // Lorem Picsum (used in seed data) 'avatars.githubusercontent.com', // GitHub profile images 'platform-lookaside.fbsbx.com', // Facebook profile images 'pbs.twimg.com', // Twitter profile images ], }, experimental: { serverComponentsExternalPackages: ['bcrypt'], }, }; module.exports = nextConfig;
```

# next-env.d.ts

```ts
/// <reference types="next" /> /// <reference types="next/image-types/global" /> // NOTE: This file should not be edited // see https://nextjs.org/docs/app/api-reference/config/typescript for more information.
```

# eslint.config.mjs

```mjs
import { dirname } from "path"; import { fileURLToPath } from "url"; import { FlatCompat } from "@eslint/eslintrc"; const __filename = fileURLToPath(import.meta.url); const __dirname = dirname(__filename); const compat = new FlatCompat({ baseDirectory: __dirname, }); const eslintConfig = [ ...compat.extends("next/core-web-vitals", "next/typescript"), ]; export default eslintConfig;
```

# README.md

```md
This is a [Next.js](https://nextjs.org) project bootstrapped with [`create-next-app`](https://nextjs.org/docs/app/api-reference/cli/create-next-app). ## Getting Started First, run the development server: \`\`\`bash npm run dev # or yarn dev # or pnpm dev # or bun dev \`\`\` Open [http://localhost:3000](http://localhost:3000) with your browser to see the result. You can start editing the page by modifying `app/page.tsx`. The page auto-updates as you edit the file. This project uses [`next/font`](https://nextjs.org/docs/app/building-your-application/optimizing/fonts) to automatically optimize and load [Geist](https://vercel.com/font), a new font family for Vercel. ## Learn More To learn more about Next.js, take a look at the following resources: - [Next.js Documentation](https://nextjs.org/docs) - learn about Next.js features and API. - [Learn Next.js](https://nextjs.org/learn) - an interactive Next.js tutorial. You can check out [the Next.js GitHub repository](https://github.com/vercel/next.js) - your feedback and contributions are welcome! ## Deploy on Vercel The easiest way to deploy your Next.js app is to use the [Vercel Platform](https://vercel.com/new?utm_medium=default-template&filter=next.js&utm_source=create-next-app&utm_campaign=create-next-app-readme) from the creators of Next.js. Check out our [Next.js deployment documentation](https://nextjs.org/docs/app/building-your-application/deploying) for more details.
```

# .prettierrc

```
{ "semi": true, "singleQuote": true, "tabWidth": 2, "trailingComma": "es5", "printWidth": 130 }
```

# .gitignore

```
# Dependencies /node_modules /.pnp .pnp.js yarn.lock package-lock.json pnpm-lock.yaml # Testing /coverage /.nyc_output /cypress/videos /cypress/screenshots # Next.js /.next/ /out/ /build .next/ next-env.d.ts # Production /build /dist # Environment variables .env .env.local .env.development.local .env.test.local .env.production.local .env.development .env.production # Debug npm-debug.log* yarn-debug.log* yarn-error.log* pnpm-debug.log* # Database /prisma/dev.db /prisma/dev.db-journal *.sqlite *.sqlite3 # IDE/Editors .idea/ .vscode/* !.vscode/extensions.json !.vscode/settings.json !.vscode/tasks.json !.vscode/launch.json *.sublime-project *.sublime-workspace *.suo *.ntvs* *.njsproj *.sln *.sw? *.swp *.swo .DS_Store Thumbs.db .~lock.* # Logs logs *.log # OS generated files .DS_Store .DS_Store? ._* .Spotlight-V100 .Trashes ehthumbs.db Thumbs.db # Misc .cache/ tsconfig.tsbuildinfo .eslintcache .stylelintcache .vercel .turbo storybook-static/ public/uploads/ # Debug .pnpm-debug.log* # Local Netlify folder .netlify package-lock.json
```

# .eslintrc.json

```json
{ "extends": [ "next/core-web-vitals", "prettier" ], "rules": { "max-len": ["error", { "code": 130 }], "react/no-unescaped-entities": "off", "@next/next/no-img-element": "off" } }
```

# public/window.svg

This is a file of the type: SVG Image

# public/vercel.svg

This is a file of the type: SVG Image

# public/next.svg

This is a file of the type: SVG Image

# public/globe.svg

This is a file of the type: SVG Image

# public/file.svg

This is a file of the type: SVG Image

# prisma/seed.ts

```ts
import { PrismaClient } from '@prisma/client'; import { hash } from 'bcrypt'; const prisma = new PrismaClient(); async function main() { // Create demo users const adminPassword = await hash('password123', 10); const admin = await prisma.user.upsert({ where: { email: 'admin@example.com' }, update: {}, create: { email: 'admin@example.com', username: 'Admin', handle: 'admin', password: adminPassword, profileImage: 'https://i.pravatar.cc/150?u=admin', bio: 'Administrator account', }, }); const user1Password = await hash('password123', 10); const user1 = await prisma.user.upsert({ where: { email: 'user1@example.com' }, update: {}, create: { email: 'user1@example.com', username: 'Jane Smith', handle: 'janesmith', password: user1Password, profileImage: 'https://i.pravatar.cc/150?u=jane', bio: 'Passionate about technology and design', }, }); const user2Password = await hash('password123', 10); const user2 = await prisma.user.upsert({ where: { email: 'user2@example.com' }, update: {}, create: { email: 'user2@example.com', username: 'John Doe', handle: 'johndoe', password: user2Password, profileImage: 'https://i.pravatar.cc/150?u=john', bio: 'Software developer and coffee enthusiast', }, }); // Create demo communities const techCommunity = await prisma.community.upsert({ where: { name: 'Tech Enthusiasts' }, update: {}, create: { name: 'Tech Enthusiasts', description: 'A community for discussing the latest in technology', image: 'https://picsum.photos/seed/tech/300/300', }, }); const travelCommunity = await prisma.community.upsert({ where: { name: 'Travel Adventures' }, update: {}, create: { name: 'Travel Adventures', description: 'Share your travel experiences and tips', image: 'https://picsum.photos/seed/travel/300/300', }, }); // Create memberships await prisma.membership.create({ data: { userId: user1.id, communityId: techCommunity.id, role: 'admin', }, }); await prisma.membership.create({ data: { userId: user2.id, communityId: techCommunity.id, role: 'member', }, }); await prisma.membership.create({ data: { userId: user2.id, communityId: travelCommunity.id, role: 'admin', }, }); // Create demo posts const post1 = await prisma.post.create({ data: { text: 'Just launched our new product! Check it out and let me know what you think.', authorId: user1.id, communityId: techCommunity.id, }, }); const post2 = await prisma.post.create({ data: { text: 'Beautiful sunset from my latest trip to Bali. The colors were absolutely incredible!', images: JSON.stringify(['https://picsum.photos/seed/bali/800/600']), authorId: user2.id, communityId: travelCommunity.id, }, }); const post3 = await prisma.post.create({ data: { text: 'What programming languages are you all learning in 2025? I\'m diving deeper into Rust and loving it so far.', authorId: user2.id, communityId: techCommunity.id, }, }); // Create follows await prisma.follow.create({ data: { followerId: user1.id, followingId: user2.id, }, }); await prisma.follow.create({ data: { followerId: user2.id, followingId: user1.id, }, }); // Create likes await prisma.like.create({ data: { postId: post1.id, userId: user2.id, }, }); await prisma.like.create({ data: { postId: post2.id, userId: user1.id, }, }); // Create comments await prisma.comment.create({ data: { text: 'This looks amazing! Can\'t wait to try it out.', postId: post1.id, authorId: user2.id, }, }); await prisma.comment.create({ data: { text: 'Wow, what a stunning view! Which beach is this?', postId: post2.id, authorId: user1.id, }, }); // Create sample advertisement await prisma.advertisement.create({ data: { title: 'Premium Subscription', content: 'Unlock all features with our Premium plan. First month 50% off!', imageUrl: 'https://picsum.photos/seed/ad1/600/400', link: 'https://example.com/premium', active: true, priority: 10, }, }); console.log('Database seeded successfully!'); } main() .then(async () => { await prisma.$disconnect(); }) .catch(async (e) => { console.error(e); await prisma.$disconnect(); process.exit(1); });
```

# prisma/schema.prisma

```prisma
// This is your Prisma schema file // Learn more about it in the docs: https://pris.ly/d/prisma-schema generator client { provider = "prisma-client-js" } datasource db { provider = "sqlite" url = env("DATABASE_URL") } model User { id String @id @default(cuid()) email String @unique username String @unique handle String @unique password String? // Nullable for social logins profileImage String? // URL to profile image bio String? createdAt DateTime @default(now()) updatedAt DateTime @updatedAt posts Post[] comments Comment[] likes Like[] bookmarks Bookmark[] followers Follow[] @relation("follower") following Follow[] @relation("following") communities Membership[] messages Message[] @relation("sender") receivedMsgs Message[] @relation("recipient") notifications Notification[] @relation("notificationTarget") causedNotifs Notification[] @relation("notificationSource") metrics UserMetrics? } model UserMetrics { id String @id @default(cuid()) user User @relation(fields: [userId], references: [id], onDelete: Cascade) userId String @unique impressionsCount Int @default(0) followersGrowth Int @default(0) postEngagement Float @default(0) // Average engagement rate updatedAt DateTime @updatedAt } model Post { id String @id @default(cuid()) text String images String? // JSON array of image URLs author User @relation(fields: [authorId], references: [id], onDelete: Cascade) authorId String createdAt DateTime @default(now()) updatedAt DateTime @updatedAt comments Comment[] likes Like[] bookmarks Bookmark[] impressions Int @default(0) community Community? @relation(fields: [communityId], references: [id]) communityId String? } model Comment { id String @id @default(cuid()) text String post Post @relation(fields: [postId], references: [id], onDelete: Cascade) postId String author User @relation(fields: [authorId], references: [id], onDelete: Cascade) authorId String createdAt DateTime @default(now()) updatedAt DateTime @updatedAt } model Like { id String @id @default(cuid()) post Post @relation(fields: [postId], references: [id], onDelete: Cascade) postId String user User @relation(fields: [userId], references: [id], onDelete: Cascade) userId String createdAt DateTime @default(now()) @@unique([postId, userId]) } model Bookmark { id String @id @default(cuid()) post Post @relation(fields: [postId], references: [id], onDelete: Cascade) postId String user User @relation(fields: [userId], references: [id], onDelete: Cascade) userId String createdAt DateTime @default(now()) @@unique([postId, userId]) } model Follow { id String @id @default(cuid()) follower User @relation("follower", fields: [followerId], references: [id], onDelete: Cascade) followerId String following User @relation("following", fields: [followingId], references: [id], onDelete: Cascade) followingId String createdAt DateTime @default(now()) @@unique([followerId, followingId]) } model Community { id String @id @default(cuid()) name String @unique description String? image String? createdAt DateTime @default(now()) updatedAt DateTime @updatedAt members Membership[] posts Post[] } model Membership { id String @id @default(cuid()) user User @relation(fields: [userId], references: [id], onDelete: Cascade) userId String community Community @relation(fields: [communityId], references: [id], onDelete: Cascade) communityId String role String @default("member") // "admin", "moderator", "member" createdAt DateTime @default(now()) @@unique([userId, communityId]) } model Message { id String @id @default(cuid()) content String sender User @relation("sender", fields: [senderId], references: [id], onDelete: Cascade) senderId String recipient User @relation("recipient", fields: [recipientId], references: [id], onDelete: Cascade) recipientId String read Boolean @default(false) createdAt DateTime @default(now()) } model Notification { id String @id @default(cuid()) type String // "follow", "like", "comment", "mention", etc. read Boolean @default(false) user User @relation("notificationTarget", fields: [userId], references: [id], onDelete: Cascade) userId String sourceUser User? @relation("notificationSource", fields: [sourceId], references: [id]) sourceId String? postId String? message String? createdAt DateTime @default(now()) } model Advertisement { id String @id @default(cuid()) title String content String imageUrl String? link String? active Boolean @default(true) priority Int @default(0) createdAt DateTime @default(now()) updatedAt DateTime @updatedAt }
```

# prisma/dev.db

This is a binary file of the type: Binary

# src/lib/validations.ts

```ts
import { z } from "zod"; // User schemas export const userSchema = z.object({ id: z.string(), email: z.string().email(), username: z.string().min(3).max(30), handle: z.string().min(3).max(30), profileImage: z.string().url().optional(), bio: z.string().max(160).optional(), createdAt: z.date(), updatedAt: z.date(), }); export const userCreateSchema = userSchema .omit({ id: true, createdAt: true, updatedAt: true }) .extend({ password: z.string().min(8).optional(), }); export const userUpdateSchema = userSchema .omit({ id: true, email: true, createdAt: true, updatedAt: true }) .partial(); // Post schemas export const postSchema = z.object({ id: z.string(), text: z.string().max(300), // 300 chars max as specified images: z.string().optional(), // JSON string of image URLs authorId: z.string(), createdAt: z.date(), updatedAt: z.date(), impressions: z.number().nonnegative(), communityId: z.string().optional(), }); export const postCreateSchema = postSchema .omit({ id: true, createdAt: true, updatedAt: true, impressions: true }) .extend({ text: z.string().min(1).max(300), }); export const postUpdateSchema = postSchema .omit({ id: true, authorId: true, createdAt: true, updatedAt: true }) .partial(); // Comment schemas export const commentSchema = z.object({ id: z.string(), text: z.string().max(300), postId: z.string(), authorId: z.string(), createdAt: z.date(), updatedAt: z.date(), }); export const commentCreateSchema = commentSchema .omit({ id: true, createdAt: true, updatedAt: true }) .extend({ text: z.string().min(1).max(300), }); // Like schema export const likeSchema = z.object({ id: z.string(), postId: z.string(), userId: z.string(), createdAt: z.date(), }); export const likeCreateSchema = likeSchema.omit({ id: true, createdAt: true }); // Bookmark schema export const bookmarkSchema = z.object({ id: z.string(), postId: z.string(), userId: z.string(), createdAt: z.date(), }); export const bookmarkCreateSchema = bookmarkSchema.omit({ id: true, createdAt: true }); // Follow schema export const followSchema = z.object({ id: z.string(), followerId: z.string(), followingId: z.string(), createdAt: z.date(), }); export const followCreateSchema = followSchema.omit({ id: true, createdAt: true }); // Community schemas export const communitySchema = z.object({ id: z.string(), name: z.string().min(3).max(50), description: z.string().max(300).optional(), image: z.string().url().optional(), createdAt: z.date(), updatedAt: z.date(), }); export const communityCreateSchema = communitySchema.omit({ id: true, createdAt: true, updatedAt: true, }); // Message schemas export const messageSchema = z.object({ id: z.string(), content: z.string().max(1000), senderId: z.string(), recipientId: z.string(), read: z.boolean(), createdAt: z.date(), }); export const messageCreateSchema = messageSchema.omit({ id: true, read: true, createdAt: true, }); // Notification schema export const notificationSchema = z.object({ id: z.string(), type: z.enum(["follow", "like", "comment", "mention", "message"]), read: z.boolean(), userId: z.string(), sourceId: z.string().optional(), postId: z.string().optional(), message: z.string().optional(), createdAt: z.date(), }); // Advertisement schema export const advertisementSchema = z.object({ id: z.string(), title: z.string().max(100), content: z.string().max(300), imageUrl: z.string().url().optional(), link: z.string().url().optional(), active: z.boolean(), priority: z.number().int(), createdAt: z.date(), updatedAt: z.date(), }); export const advertisementCreateSchema = advertisementSchema.omit({ id: true, createdAt: true, updatedAt: true, active: true, priority: true, }); // Authentication schemas export const signUpSchema = z.object({ email: z.string().email(), username: z.string().min(3).max(30), handle: z.string().min(3).max(30), password: z.string().min(8), }); export const signInSchema = z.object({ emailOrUsername: z.string(), password: z.string(), }); // Feed configuration schema export const feedPreferencesSchema = z.object({ showFollowing: z.boolean().default(true), showForYou: z.boolean().default(true), communityIds: z.array(z.string()).default([]), }); // Optional type helpers export type User = z.infer<typeof userSchema>; export type Post = z.infer<typeof postSchema>; export type Comment = z.infer<typeof commentSchema>; export type Like = z.infer<typeof likeSchema>; export type Bookmark = z.infer<typeof bookmarkSchema>; export type Follow = z.infer<typeof followSchema>; export type Community = z.infer<typeof communitySchema>; export type Message = z.infer<typeof messageSchema>; export type Notification = z.infer<typeof notificationSchema>; export type Advertisement = z.infer<typeof advertisementSchema>;
```

# src/lib/db.ts

```ts
import { PrismaClient } from '@prisma/client'; // PrismaClient is attached to the `global` object in development to prevent // exhausting your database connection limit. // Learn more: https://pris.ly/d/help/next-js-best-practices const globalForPrisma = global as unknown as { prisma: PrismaClient }; export const prisma = globalForPrisma.prisma || new PrismaClient(); if (process.env.NODE_ENV !== 'production') globalForPrisma.prisma = prisma; export default prisma;
```

# src/lib/db.test.ts

```ts
import prisma from './db'; describe('Database Connection', () => { beforeAll(async () => { // Clean up the database before tests await prisma.like.deleteMany(); await prisma.comment.deleteMany(); await prisma.post.deleteMany(); await prisma.follow.deleteMany(); await prisma.membership.deleteMany(); await prisma.community.deleteMany(); await prisma.user.deleteMany(); }); afterAll(async () => { // Disconnect after tests await prisma.$disconnect(); }); it('should connect to the database', async () => { // Simple test to verify connection const user = await prisma.user.create({ data: { email: 'test@example.com', username: 'testuser', handle: 'testhandle', }, }); expect(user).toHaveProperty('id'); expect(user.email).toBe('test@example.com'); // Clean up await prisma.user.delete({ where: { id: user.id }, }); }); });
```

# src/lib/auth.ts

```ts
// src/lib/auth.ts import { NextAuthOptions } from 'next-auth'; import CredentialsProvider from 'next-auth/providers/credentials'; import GitHubProvider from 'next-auth/providers/github'; import GoogleProvider from 'next-auth/providers/google'; import FacebookProvider from 'next-auth/providers/facebook'; import TwitterProvider from 'next-auth/providers/twitter'; import { compare } from 'bcrypt'; import prisma from './db'; import { signInSchema } from './validations'; async function upsertSocialUser(profile: { email?: string; name?: string; image?: string; }) { if (!profile.email) return null; let user = await prisma.user.findUnique({ where: { email: profile.email } }); if (user) return user; user = await prisma.user.create({ data: { email: profile.email, username: profile.name?.replace(/\s+/g, '') ?? `user${Date.now()}`, handle: profile.name?.replace(/\s+/g, '').toLowerCase() ?? `user${Date.now()}`, profileImage: profile.image, }, }); return user; } export const authOptions: NextAuthOptions = { session: { strategy: 'jwt' }, providers: [ CredentialsProvider({ name: 'Credentials', credentials: { emailOrUsername: { label: 'Email or Username', type: 'text' }, password: { label: 'Password', type: 'password' }, }, async authorize(credentials) { const parsed = signInSchema.safeParse(credentials); if (!parsed.success) return null; const { emailOrUsername, password } = parsed.data; const user = await prisma.user.findFirst({ where: { OR: [{ email: emailOrUsername }, { username: emailOrUsername }], }, }); if (!user || !user.password) return null; const ok = await compare(password, user.password); if (!ok) return null; return { id: user.id, email: user.email, name: user.username, image: user.profileImage ?? undefined, }; }, }), GitHubProvider({ clientId: process.env.GITHUB_ID!, clientSecret: process.env.GITHUB_SECRET!, }), GoogleProvider({ clientId: process.env.GOOGLE_ID!, clientSecret: process.env.GOOGLE_SECRET!, }), FacebookProvider({ clientId: process.env.FACEBOOK_ID!, clientSecret: process.env.FACEBOOK_SECRET!, }), TwitterProvider({ clientId: process.env.TWITTER_ID!, clientSecret: process.env.TWITTER_SECRET!, version: '2.0', }), ], callbacks: { async jwt({ token, user, account }) { if (account) { const dbUser = await upsertSocialUser({ email: token.email, name: token.name, image: (token as any).picture ?? (token as any).image, }); if (dbUser) { token.id = dbUser.id; } } else if (user) { token.id = user.id; } return token; }, async session({ session, token }) { if (token.id) { session.user.id = token.id as string; } let details = null; if (token.id) { details = await prisma.user.findUnique({ where: { id: token.id as string }, select: { handle: true, username: true }, }); } if (!details && session.user.email) { details = await prisma.user.findUnique({ where: { email: session.user.email }, select: { handle: true, username: true }, }); } if (details) { session.user.handle = details.handle; session.user.username = details.username; } return session; }, }, pages: { signIn: '/auth/signin', error: '/auth/error', }, }; declare module 'next-auth' { interface Session { user: { id: string; email: string; image?: string; handle: string; username: string; }; } }
```

# prisma/migrations/migration_lock.toml

```toml
# Please do not edit this file manually # It should be added in your version-control system (e.g., Git) provider = "sqlite"
```

# src/context/ui-context.tsx

```tsx
// src/context/ui-context.tsx 'use client'; import { createContext, useContext, useState, useEffect, ReactNode } from 'react'; import { usePathname } from 'next/navigation'; type UIContextType = { sidebarOpen: boolean; setSidebarOpen: (open: boolean) => void; toggleSidebar: () => void; darkMode: boolean; toggleDarkMode: () => void; tabBarVisible: boolean; }; const UIContext = createContext<UIContextType | undefined>(undefined); export function UIProvider({ children }: { children: ReactNode }) { const [sidebarOpen, setSidebarOpen] = useState(true); const [darkMode, setDarkMode] = useState(false); const [scrollPosition, setScrollPosition] = useState(0); const [tabBarVisible, setTabBarVisible] = useState(true); const pathname = usePathname(); const toggleSidebar = () => setSidebarOpen(prev => !prev); const toggleDarkMode = () => { const newMode = !darkMode; setDarkMode(newMode); try { localStorage.setItem('darkMode', newMode.toString()); } catch { } if (newMode) { document.documentElement.classList.add('dark'); } else { document.documentElement.classList.remove('dark'); } }; // On mount, initialize from localStorage useEffect(() => { let saved = false; try { saved = localStorage.getItem('darkMode') === 'true'; } catch { } if (saved) { setDarkMode(true); document.documentElement.classList.add('dark'); } }, []); // Hide/show tab bar on scroll useEffect(() => { const handleScroll = () => { const current = window.scrollY; setTabBarVisible(scrollPosition > current || current < 50); setScrollPosition(current); }; window.addEventListener('scroll', handleScroll); return () => window.removeEventListener('scroll', handleScroll); }, [scrollPosition]); // Adjust sidebar for mobile vs. desktop useEffect(() => { const handleResize = () => { setSidebarOpen(window.innerWidth >= 768); }; window.addEventListener('resize', handleResize); handleResize(); return () => window.removeEventListener('resize', handleResize); }, []); // Close mobile sidebar on navigation useEffect(() => { if (window.innerWidth < 768) setSidebarOpen(false); }, [pathname]); return ( <UIContext.Provider value={{ sidebarOpen, setSidebarOpen, toggleSidebar, darkMode, toggleDarkMode, tabBarVisible, }} > {children} </UIContext.Provider> ); } export function useUI() { const context = useContext(UIContext); if (!context) { throw new Error('useUI must be used within a UIProvider'); } return context; }
```

# src/context/feed-context.tsx

```tsx
'use client'; import { createContext, useContext, useState, useEffect, ReactNode, useCallback } from 'react'; import { useSession } from 'next-auth/react'; import { Post, Community } from '@/lib/validations'; type FeedTab = 'for-you' | 'following' | string; // string is for community IDs type FeedContextType = { activeTab: FeedTab; setActiveTab: (tab: FeedTab) => void; userCommunities: Community[]; posts: Post[]; loading: boolean; error: string | null; hasMore: boolean; loadMorePosts: () => Promise<void>; refreshFeed: () => Promise<void>; }; const FeedContext = createContext<FeedContextType | undefined>(undefined); export function FeedProvider({ children }: { children: ReactNode }) { const [activeTab, setActiveTab] = useState<FeedTab>('for-you'); const [userCommunities, setUserCommunities] = useState<Community[]>([]); const [posts, setPosts] = useState<Post[]>([]); const [loading, setLoading] = useState(false); const [error, setError] = useState<string | null>(null); const [page, setPage] = useState(1); const [hasMore, setHasMore] = useState(true); const { data: session } = useSession(); // Fetch user's communities useEffect(() => { if (session?.user.id) { fetchUserCommunities(); } }, [session?.user.id]); const fetchUserCommunities = async () => { try { const response = await fetch(`/api/communities/user`); if (!response.ok) throw new Error('Failed to fetch communities'); const data = await response.json(); setUserCommunities(data); } catch (err) { setError(err instanceof Error ? err.message : 'Failed to fetch communities'); } }; const fetchPosts = useCallback(async (pageNum: number, replace = false) => { if (loading) return; setLoading(true); setError(null); try { let endpoint; if (activeTab === 'for-you') { endpoint = `/api/posts/for-you?page=${pageNum}`; } else if (activeTab === 'following') { endpoint = `/api/posts/following?page=${pageNum}`; } else { // Community tab endpoint = `/api/communities/${activeTab}/posts?page=${pageNum}`; } const response = await fetch(endpoint); if (!response.ok) throw new Error('Failed to fetch posts'); const data = await response.json(); if (data.length === 0) { setHasMore(false); } else { setPage(pageNum); setPosts(prev => (replace ? data : [...prev, ...data])); } } catch (err) { setError(err instanceof Error ? err.message : 'Failed to fetch posts'); } finally { setLoading(false); } }, [activeTab, loading]); const loadMorePosts = useCallback(async () => { if (hasMore && !loading) { await fetchPosts(page + 1); } }, [fetchPosts, hasMore, loading, page]); const refreshFeed = useCallback(async () => { setPage(1); setHasMore(true); await fetchPosts(1, true); }, [fetchPosts]); // Fetch posts when active tab changes useEffect(() => { if (session?.user.id) { refreshFeed(); } }, [activeTab, session?.user.id, refreshFeed]); return ( <FeedContext.Provider value={{ activeTab, setActiveTab, userCommunities, posts, loading, error, hasMore, loadMorePosts, refreshFeed, }} > {children} </FeedContext.Provider> ); } export function useFeed() { const context = useContext(FeedContext); if (context === undefined) { throw new Error('useFeed must be used within a FeedProvider'); } return context; }
```

# src/hooks/useFollowUser.ts

```ts
import { useState, useCallback } from 'react'; import { useSession } from 'next-auth/react'; interface UseFollowUserResult { isFollowing: boolean; isLoading: boolean; error: string | null; toggleFollow: () => Promise<void>; } export default function useFollowUser(userId: string, initialFollowState = false): UseFollowUserResult { const { data: session } = useSession(); const [isFollowing, setIsFollowing] = useState<boolean>(initialFollowState); const [isLoading, setIsLoading] = useState<boolean>(false); const [error, setError] = useState<string | null>(null); const toggleFollow = useCallback(async () => { if (!session?.user) { setError('You must be signed in to follow users'); return; } // Don't allow following self if (session.user.id === userId) { setError('You cannot follow yourself'); return; } try { setIsLoading(true); setError(null); const method = isFollowing ? 'DELETE' : 'POST'; const response = await fetch(`/api/users/${userId}/follow`, { method, headers: { 'Content-Type': 'application/json', }, }); if (!response.ok) { const data = await response.json(); throw new Error(data.error || 'Failed to update follow status'); } // Toggle the following state setIsFollowing(!isFollowing); } catch (err) { setError(err instanceof Error ? err.message : 'An error occurred'); console.error('Error toggling follow:', err); } finally { setIsLoading(false); } }, [session, userId, isFollowing]); return { isFollowing, isLoading, error, toggleFollow, }; }
```

# src/docs/UserGuide.md

```md
# Social Media Application User Guide Welcome to our social media platform! This guide will help you navigate and make the most of our application. ## Table of Contents 1. [Getting Started](#getting-started) 2. [Navigation](#navigation) 3. [Your Feed](#your-feed) 4. [Creating Posts](#creating-posts) 5. [Interacting with Content](#interacting-with-content) 6. [Communities](#communities) 7. [Messaging](#messaging) 8. [Notifications](#notifications) 9. [Your Profile](#your-profile) 10. [Analytics](#analytics) 11. [Settings](#settings) 12. [Mobile Features](#mobile-features) 13. [Troubleshooting](#troubleshooting) ## Getting Started ### Creating an Account 1. Visit the application and click "Sign up" if you're a new user 2. Choose from one of these registration options: - Email and password - GitHub account - Google account - Facebook account - Twitter account 3. If registering with email, enter: - Email address - Username - Handle (your unique @name) - Password (minimum 8 characters) 4. Click "Sign up" to create your account ### Signing In 1. Click "Sign in" if you already have an account 2. Enter your email or username and password 3. Or choose one of the social login options 4. Check "Remember me" to stay signed in ## Navigation ### Left Sidebar The main navigation menu on the left side of the screen provides access to all key areas: - **Home**: Returns to the main feed - **Search**: Find users, posts, and communities - **Notifications**: View your activity notifications - **Messages**: Access your private conversations - **Profile**: View and edit your profile - **Analytics**: See insights about your account activity - **Communities**: Discover and manage communities - **Settings**: Configure your account preferences You can collapse the sidebar by clicking the menu icon at the top of the sidebar. On mobile devices, the sidebar will be collapsed by default and replaced with a footer navigation bar. ### Dark Mode Toggle between light and dark modes using the sun/moon icon at the bottom of the sidebar. ## Your Feed ### Feed Types The application offers multiple feed types, accessible via tabs at the top of the home page: - **For You**: Personalized content based on your interests, follows, and previous interactions - **Following**: Posts only from users you follow - **Communities**: Posts from specific communities you've joined (shown as additional tabs) ### Navigating the Feed - Scroll down to view more content - The app will automatically load more posts as you reach the bottom (infinite scrolling) - The tab bar will automatically hide as you scroll down and reappear when you scroll up ## Creating Posts 1. Click the floating "+" button in the bottom right corner of the screen 2. In the post creation modal: - Type your post text (maximum 300 characters) - Add images by clicking the image icon (up to 4 images) - Add emojis, location, or other content as desired 3. Click "Post" to publish your content ## Interacting with Content ### Post Interactions Each post in your feed allows several types of interaction: - **Comment**: Click the comment icon to view existing comments or add your own - **Repost**: Share someone else's post to your followers - **Like**: Show appreciation for content - **View Stats**: See how many impressions the post has received - **Bookmark**: Save posts to read later - **Share**: Send the post to others outside the platform ### Finding Content Use the Search feature to: - Find specific users by name or handle - Discover posts by keyword - Browse trending topics - Locate communities of interest ## Communities Communities are groups of users with shared interests. ### Joining Communities 1. Navigate to the Communities section 2. Browse featured or recommended communities 3. Click on a community to view its content 4. Click "Join" to become a member ### Community Feeds When you join communities, they appear as additional tabs in your feed navigation. Click on a community tab to see posts specifically from that community. ## Messaging ### Starting Conversations 1. Navigate to the Messages section 2. Click the compose button to start a new conversation 3. Search for and select the user you want to message 4. Type your message and press Enter to send ### Managing Conversations - Conversations are listed in the left sidebar of the Messages page - Click on a conversation to view and continue the chat - Search functionality allows you to find specific conversations ## Notifications The Notifications page shows all activities related to your account: - When someone follows you - Likes on your posts - Comments on your posts - Mentions of your handle - New messages - Community invitations Click a notification to navigate directly to the relevant content. ## Your Profile ### Viewing Your Profile 1. Click on your username in the sidebar 2. Or navigate to the Profile section ### Profile Information Your profile displays: - Profile picture - Username and handle - Bio - Follower and following counts - Your posts ### Editing Your Profile 1. On your profile page, click "Edit Profile" 2. Update your: - Profile picture - Bio - Display name - Other profile information 3. Click "Save" to apply changes ## Analytics The Analytics page provides insights about your account activity: ### Available Metrics - **Post Engagement**: Track likes, comments, and shares on your content - **Post Impressions**: See how many people view your posts - **Content Type Distribution**: Analyze what types of content perform best - **Follower Growth**: Monitor how your audience grows over time ### Using Analytics - Adjust the time range to view different periods - Hover over charts for detailed information - Use insights to optimize your posting strategy ## Settings The Settings page allows you to configure: - Account information - Privacy settings - Notification preferences - Display options - Security settings ## Mobile Features When using the application on mobile devices or with a collapsed sidebar: - The main navigation moves to a footer bar - Tap the footer icons to navigate between main sections - The floating action button remains available for creating posts - Swipe gestures can be used in various parts of the app ## Troubleshooting ### Common Issues - **Content not loading**: Pull down to refresh the feed - **Unable to post**: Check your internet connection - **Login problems**: Use the password recovery option if needed ### Getting Help If you encounter any issues that aren't covered in this guide: - Check the FAQ section in Settings - Contact support through the app - Visit our help center website
```

# src/docs/TechnicalGuide.md

```md
# Social Media Application Technical Guide This document provides technical details for developers working with this social media application. It covers architecture, setup instructions, and development guidelines. ## Table of Contents 1. [Architecture Overview](#architecture-overview) 2. [Environment Setup](#environment-setup) 3. [Project Structure](#project-structure) 4. [Key Technologies](#key-technologies) 5. [Database Design](#database-design) 6. [Authentication](#authentication) 7. [API Endpoints](#api-endpoints) 8. [State Management](#state-management) 9. [Component Architecture](#component-architecture) 10. [Testing](#testing) 11. [Performance Optimization](#performance-optimization) 12. [Deployment](#deployment) 13. [Contribution Guidelines](#contribution-guidelines) ## Architecture Overview This application follows a modern React-based architecture with Next.js, utilizing the App Router for server-side rendering and API routes for backend functionality. ### Key Architectural Decisions - **Full Stack Framework**: Next.js for both frontend and backend - **Database Access**: Prisma ORM for type-safe database operations - **Authentication**: NextAuth.js for secure user authentication - **State Management**: React Context API for global state - **Styling**: Tailwind CSS for utility-first styling - **Form Handling**: React Hook Form with Zod validation - **Data Visualization**: Recharts for analytics ## Environment Setup ### Prerequisites - Node.js 18+ - npm or yarn - Git ### Installation Steps 1. Clone the repository: \`\`\`bash git clone https://github.com/yourusername/social-media-app.git cd social-media-app \`\`\` 2. Install dependencies: \`\`\`bash npm install # or yarn install \`\`\` 3. Set up environment variables: - Copy `.env.example` to `.env.local` - Fill in the required variables: \`\`\` DATABASE_URL="file:./dev.db" NEXTAUTH_SECRET="your-secret-key" NEXTAUTH_URL="http://localhost:3000" # OAuth providers GITHUB_ID="your-github-id" GITHUB_SECRET="your-github-secret" GOOGLE_ID="your-google-id" GOOGLE_SECRET="your-google-secret" FACEBOOK_ID="your-facebook-id" FACEBOOK_SECRET="your-facebook-secret" TWITTER_ID="your-twitter-id" TWITTER_SECRET="your-twitter-secret" \`\`\` 4. Initialize the database: \`\`\`bash npx prisma migrate dev --name init \`\`\` 5. Start the development server: \`\`\`bash npm run dev # or yarn dev \`\`\` ## Project Structure The project follows a feature-based organization within the Next.js App Router structure: \`\`\` src/ ├── app/ # Next.js App Router │ ├── api/ # API routes │ ├── (routes)/ # Page routes │ └── layout.tsx # Root layout ├── components/ # Reusable components │ ├── feed/ # Feed components │ ├── layout/ # Layout components │ ├── post/ # Post components │ └── ui/ # UI components ├── context/ # React context providers ├── hooks/ # Custom React hooks ├── lib/ # Utility functions │ ├── auth.ts # Authentication config │ ├── db.ts # Database client │ └── validations.ts # Zod schemas ├── prisma/ # Prisma schema and migrations └── public/ # Static assets \`\`\` ## Key Technologies ### Frontend - **React 18**: Component-based UI library - **Next.js 13+**: React framework with App Router - **TypeScript**: Type-safe JavaScript - **Tailwind CSS**: Utility-first CSS framework - **Radix UI**: Unstyled, accessible UI components - **Lucide React**: Icon library - **Recharts**: Composable charting library - **React Hook Form**: Form state management - **Zod**: Schema validation ### Backend - **Next.js API Routes**: Serverless API endpoints - **Prisma**: ORM for database operations - **SQLite**: Database (production would use PostgreSQL) - **NextAuth.js**: Authentication framework - **bcrypt**: Password hashing ## Database Design The database is designed with the following core models: ### Core Entities - **User**: Account information and profile data - **Post**: User-created content - **Comment**: Responses to posts - **Like**: User reactions to posts - **Bookmark**: Saved posts - **Follow**: User connections - **Community**: User groups - **Membership**: User-community relationships - **Message**: Private communications - **Notification**: System and user activity alerts - **Advertisement**: Promotional content - **UserMetrics**: Analytics data ### Key Relationships The schema includes various relationships: - One-to-many (User to Posts) - Many-to-many (Users to Communities via Memberships) - Self-referential (User follows User) - Polymorphic-like (Notifications with different sources) See the Prisma schema for detailed field definitions and relations. ## Authentication The application uses NextAuth.js for authentication with the following features: ### Authentication Methods - Email/password (credentials provider) - OAuth providers: - GitHub - Google - Facebook - Twitter ### Session Management - JWT-based sessions - Custom session handling to include user details - Secure HTTP-only cookies ### Protected Routes - Server-side session verification for API routes - Client-side protection via useSession hook - Redirect handling for unauthenticated users ## API Endpoints The application provides RESTful API endpoints: ### Post Management - `GET /api/posts` - List posts (paginated) - `GET /api/posts/for-you` - Get personalized feed - `GET /api/posts/following` - Get following feed - `POST /api/posts` - Create post - `GET /api/posts/:id` - Get post details - `PUT /api/posts/:id` - Update post - `DELETE /api/posts/:id` - Delete post - `POST /api/posts/:id/like` - Like post - `DELETE /api/posts/:id/like` - Unlike post - `POST /api/posts/:id/bookmark` - Bookmark post - `DELETE /api/posts/:id/bookmark` - Remove bookmark ### User Management - `GET /api/users/:id` - Get user profile - `PUT /api/users/:id` - Update user profile - `GET /api/users/:id/posts` - Get user posts - `POST /api/users/:id/follow` - Follow user - `DELETE /api/users/:id/follow` - Unfollow user - `GET /api/users/:id/follow-counts` - Get follower/following counts ### Messaging - `GET /api/messages/conversations` - List conversations - `GET /api/messages/:userId` - Get conversation with user - `POST /api/messages` - Send message ### Notifications - `GET /api/notifications` - Get notifications - `POST /api/notifications/mark-read` - Mark notifications as read ### Communities - `GET /api/communities` - List communities - `GET /api/communities/user` - Get user's communities - `GET /api/communities/:id/posts` - Get community posts - `POST /api/communities/:id/join` - Join community ### Ads - `GET /api/ads` - Get advertisements ## State Management The application uses React Context for state management: ### Core Context Providers - **UIContext**: Manages UI state (sidebar, dark mode, tab visibility) - **FeedContext**: Manages feed state (active tab, posts, loading) - **AuthContext**: Wraps NextAuth for authentication state ### Usage Pattern \`\`\`tsx // Context definition export const UIContext = createContext<UIContextType | undefined>(undefined); // Provider implementation export function UIProvider({ children }: { children: ReactNode }) { const [sidebarOpen, setSidebarOpen] = useState(true); // ...other state return ( <UIContext.Provider value={{ sidebarOpen, setSidebarOpen, /* other values */ }}> {children} </UIContext.Provider> ); } // Custom hook for consuming context export function useUI() { const context = useContext(UIContext); if (context === undefined) { throw new Error('useUI must be used within a UIProvider'); } return context; } \`\`\` ## Component Architecture Components follow a hierarchical structure with clear separation of concerns: ### Component Types - **Page Components**: Top-level components for routes - **Feature Components**: Implement specific features (Feed, PostCard) - **Layout Components**: Structure the application (Sidebar, MobileFooter) - **UI Components**: Reusable UI elements (Button, Input) ### Component Guidelines - Maximum file length: 200 lines - Maximum line length: 130 characters - Each component should have a single responsibility - Use composition over inheritance - Props should be typed with TypeScript interfaces - Use destructuring for props ### Example Component \`\`\`tsx interface ButtonProps { variant?: 'primary' | 'secondary' | 'outline'; size?: 'sm' | 'md' | 'lg'; children: React.ReactNode; onClick?: () => void; disabled?: boolean; } export function Button({ variant = 'primary', size = 'md', children, onClick, disabled = false, }: ButtonProps) { // Component implementation } \`\`\` ## Testing The application uses the following testing approaches: ### Testing Tools - Jest for unit and integration tests - React Testing Library for component tests - Cypress for end-to-end tests ### Testing Patterns - Unit tests for utilities and hooks - Component tests for UI behavior - Integration tests for complex features - E2E tests for critical user flows ### Example Test \`\`\`tsx import { render, screen, fireEvent } from '@testing-library/react'; import { Button } from './Button'; describe('Button', () => { it('renders correctly', () => { render(<Button>Click me</Button>); expect(screen.getByText('Click me')).toBeInTheDocument(); }); it('calls onClick when clicked', () => { const handleClick = jest.fn(); render(<Button onClick={handleClick}>Click me</Button>); fireEvent.click(screen.getByText('Click me')); expect(handleClick).toHaveBeenCalledTimes(1); }); }); \`\`\` ## Performance Optimization Several techniques are used for optimal performance: ### Rendering Optimizations - React.memo for expensive components - useMemo and useCallback for computational stability - Virtualized lists for long content - Image optimization with Next.js Image component ### Data Fetching - SWR for client-side data fetching with caching - Strategic use of SSR/SSG for initial page load - Pagination and infinite scrolling for data-heavy views ### Code Splitting - Dynamic imports for route-based code splitting - Lazy loading of heavy components - Bundle analyzer to identify optimization opportunities ## Deployment ### Deployment Options - Vercel (recommended for Next.js) - Netlify - AWS Amplify - Self-hosted options ### Deployment Process 1. Set up production environment variables 2. Build the application: \`\`\`bash npm run build # or yarn build \`\`\` 3. Migrate the database (if needed) 4. Deploy to your hosting provider: \`\`\`bash npm run deploy # or yarn deploy \`\`\` ### CI/CD Configuration The project includes GitHub Actions workflows for: - Linting and type checking - Running tests - Automatic deployment to staging/production ## Contribution Guidelines ### Code Style - Follow the ESLint and Prettier configuration - Use meaningful variable and function names - Comment complex logic - Write documentation for public APIs ### Git Workflow 1. Create feature branches from `develop` 2. Use conventional commit messages 3. Create pull requests for review 4. Squash and merge to maintain clean history ### Review Process - All code changes require at least one review - Automated checks must pass (lint, type check, tests) - Changes should include appropriate tests - Documentation should be updated if necessary ### Development Workflow 1. Pick an issue from the board 2. Create a feature branch 3. Implement the changes with tests 4. Create a pull request 5. Address review feedback 6. Merge when approved
```

# src/docs/Tasks.md

```md
# Social Media Application Tasks This document tracks all tasks for the social media application development, their status, and relevant comments. ## Status Legend - 🟢 **Complete** - Task has been implemented and tested - 🟡 **In Progress** - Task is currently being worked on - 🔴 **Not Started** - Task has not been started yet - 🟠 **Blocked** - Task is blocked by another task or issue - 🔵 **Review** - Task is completed but needs review - ⚪ **Deferred** - Task has been postponed for a later phase ## Project Setup | Task | Status | Comments | |------|--------|----------| | Initialize Next.js project with TypeScript | 🟢 | Project created with `create-next-app` | | Configure ESLint and Prettier | 🟢 | Added `.eslintrc.json` and `.prettierrc` | | Configure Tailwind CSS | 🟢 | Tailwind is set up with `postcss.config.mjs` | | Set up project directory structure | 🟢 | Created app, components, lib, and other directories | | Set up environment variables | 🟢 | Created `.env.example` for reference | | Add README with setup instructions | 🟢 | Basic README with setup and run instructions | ## Database & Data Models | Task | Status | Comments | |------|--------|----------| | Set up Prisma ORM | 🟢 | Prisma client configured in `src/lib/db.ts` | | Define User model | 🟢 | Includes fields for profile, auth, etc. | | Define Post model | 🟢 | Contains text, images, and author relations | | Define Comment model | 🟢 | For post comments with relations | | Define Like model | 🟢 | For storing post likes | | Define Bookmark model | 🟢 | For saving posts | | Define Follow model | 🟢 | For user-to-user follow relationships | | Define Community model | 🟢 | For interest-based groups | | Define Membership model | 🟢 | For community relationships | | Define Message model | 🟢 | For private messaging | | Define Notification model | 🟢 | For system notifications | | Define Advertisement model | 🟢 | For sponsored content | | Define UserMetrics model | 🟢 | For analytics data | | Create initial migration | 🟢 | Migration created with schema design | | Create seed script | 🟢 | Added demo data for testing | ## Authentication System | Task | Status | Comments | |------|--------|----------| | Set up NextAuth.js | 🟢 | Configured in `src/lib/auth.ts` | | Implement email/password provider | 🟢 | Using credentials provider with bcrypt | | Set up GitHub OAuth provider | 🟢 | Working with GitHub login | | Set up Google OAuth provider | 🟢 | Working with Google login | | Set up Facebook OAuth provider | 🟢 | Working with Facebook login | | Set up Twitter OAuth provider | 🟢 | Working with Twitter login | | Create sign-in page | 🟢 | Page with social and credential options | | Create sign-up page | 🟢 | User registration with validation | | Create auth error page | 🟢 | Displays auth-related errors | | Implement protected routes | 🟢 | Using session checks | | Implement user session handling | 🟢 | Session with user details | ## Core UI Components | Task | Status | Comments | |------|--------|----------| | Create layout component | 🟢 | Root layout with session provider | | Create sidebar component | 🟢 | For navigation with profile section | | Implement dark mode toggle | 🟢 | With localStorage persistence | | Create mobile footer navigation | 🟢 | For smaller screens | | Create button component | 🟡 | Basic implementation, needs refinement | | Create input component | 🔴 | Not started yet | | Create modal component | 🟡 | Basic modal for post creation | | Create card components | 🟢 | For posts and other content | | Create loader component | 🟢 | For loading states | ## Feed Functionality | Task | Status | Comments | |------|--------|----------| | Create feed context | 🟢 | Managing feed state | | Implement "For You" algorithm | 🟡 | Basic implementation, needs refinement | | Implement "Following" feed | 🟢 | Content from followed users | | Create infinite scroll | 🟢 | Using intersection observer | | Create tab bar component | 🟢 | For switching feed types | | Implement feed pagination | 🟢 | Server-side with skip/take | | Create API for fetching posts | 🟢 | With various endpoints | | Create PostCard component | 🟢 | With interaction buttons | | Implement ad placement | 🟢 | One ad per 10 posts | ## User Profiles & Follow System | Task | Status | Comments | |------|--------|----------| | Create profile page | 🟡 | Basic profile page created, needs refinement | | Create profile edit functionality | 🟡 | UI form wired to `PUT /api/users/:id`, Zod-validated | | Implement follow system | 🟢 | API routes and UI components | | Create follow button component | 🟢 | With multiple variants | | Implement followers page | 🟢 | List of user followers | | Implement following page | 🟢 | List of followed users | | Create follow stats component | 🟢 | Display counts with links | | Create API for follow operations | 🟢 | Follow/unfollow endpoints | | Implement follow notifications | 🟢 | For new followers | ## Post Creation & Interaction | Task | Status | Comments | |------|--------|----------| | Create post creation modal | 🟢 | With text and image support | | Implement post character count | 🟢 | With 300 char limit | | Create floating action button | 🟢 | For creating new posts | | Implement like functionality | 🟢 | With API and UI | | Implement comment functionality | 🟡 | Frontend UI in progress (API ready) | | Implement bookmark functionality | 🟡 | Bookmark button added; pending toast & icon feedback | | Create image upload functionality | 🟡 | Endpoint defined; client-side preview & progress needed | | Implement post sharing | 🔴 | Not started yet | ## Messaging System | Task | Status | Comments | |------|--------|----------| | Create messages page | 🟢 | With conversation list | | Implement conversation view | 🟢 | With message history | | Create message input | 🟢 | For sending messages | | Implement message read status | 🟢 | Tracking read/unread | | Create conversation list | 🟢 | With recent messages | | Implement messaging API | 🔴 | Models defined but endpoints not implemented | | Add real-time messaging | 🔴 | Needs WebSocket integration | ## Notification System | Task | Status | Comments | |------|--------|----------| | Create notifications page | 🟢 | With notification list | | Implement notification types | 🟢 | Like, comment, follow, etc. | | Create notification API | 🟢 | Basic CRUD operations | | Implement mark-as-read | 🟢 | For tracking notification state | | Create notification generation | 🟢 | For various activities | | Implement real-time notifications | 🔴 | Needs WebSocket integration | ## Communities | Task | Status | Comments | |------|--------|----------| | Create communities page | 🟡 | Basic layout & route scaffolding complete | | Implement community creation | 🔴 | Not started yet | | Create community profile | 🔴 | Not started yet | | Implement join/leave functionality | 🔴 | Not started yet | | Create community feed | 🔴 | Not started yet | | Implement community API | 🟡 | Models defined; endpoints for join/leave in dev | ## Analytics | Task | Status | Comments | |------|--------|----------| | Create analytics page | 🟢 | With various charts | | Implement post engagement metrics | 🟢 | Likes, comments, shares | | Create impression tracking | 🟢 | For post views | | Implement follower growth tracking | 🟢 | With metrics model | | Create content type analysis | 🟢 | For content distribution | | Implement data visualization | 🟢 | Using Recharts | ## Search Functionality | Task | Status | Comments | |------|--------|----------| | Create search page | 🟡 | Tabs for users/posts/communities under development | | Implement user search | 🔴 | Not started yet | | Implement post search | 🔴 | Not started yet | | Create community search | 🔴 | Not started yet | | Implement search API | 🟡 | Debounce, pagination & error states pending | | Create search results display | 🔴 | Not started yet | ## Settings & User Preferences | Task | Status | Comments | |------|--------|----------| | Create settings page | 🔴 | Not started yet | | Implement profile settings | 🔴 | Not started yet | | Create privacy settings | 🔴 | Not started yet | | Implement notification preferences | 🔴 | Not started yet | | Create account settings | 🔴 | Not started yet | | Implement theme settings | 🟡 | Dark mode implemented, other settings needed | ## Performance Optimization | Task | Status | Comments | |------|--------|----------| | Implement image optimization | 🟡 | Using Next.js Image but needs improvement | | Add code splitting | 🟢 | Automatic with Next.js App Router | | Optimize database queries | 🟡 | Some optimization done | | Implement caching | 🔴 | Not started yet | | Optimize bundle size | 🔴 | Not started yet | | Add lazy loading | 🟡 | For images and some components | ## Testing | Task | Status | Comments | |------|--------|----------| | Set up Jest | 🔴 | Not started yet | | Write unit tests for utilities | 🔴 | Not started yet | | Create component tests | 🔴 | Not started yet | | Implement API tests | 🔴 | Not started yet | | Create end-to-end tests | 🔴 | Not started yet | | Set up CI/CD testing | 🔴 | Not started yet | ## Deployment | Task | Status | Comments | |------|--------|----------| | Configure production environment | 🔴 | Not started yet | | Set up database for production | 🔴 | Not started yet | | Configure CI/CD pipeline | 🔴 | Not started yet | | Implement deployment scripts | 🔴 | Not started yet | | Set up monitoring | 🔴 | Not started yet | | Create backup strategy | 🔴 | Not started yet | ## Documentation | Task | Status | Comments | |------|--------|----------| | Create API documentation | 🟡 | Some endpoints documented | | Write setup instructions | 🟢 | Basic setup in README | | Create code style guide | 🔴 | ESLint/Prettier configured, but no actual guide document | | Document database schema | 🟢 | In Prisma schema | | Create user guide | 🟡 | Initial draft created, needs updating as features develop | | Document development process | 🟢 | Development plan created | | Maintain task list | 🟢 | This document! | ## Bugs & Issues | Issue | Status | Priority | Comments | |-------|--------|----------|----------| | Fix mobile navigation on small screens | 🔴 | Medium | Navigation needs adjustment | | Handle image upload errors | 🟡 | High | Added retry logic & user‑friendly messages | | Fix dark mode persistence bug | 🔴 | Low | | | Optimize feed loading performance | 🟡 | Medium | Initial load is slow | | Fix notification count display | 🔴 | Low | | ## Future Enhancements | Feature | Status | Priority | Comments | |---------|--------|----------|----------| | Add video uploads | ⚪ | Low | For phase 2 | | Implement live streaming | ⚪ | Low | For future consideration | | Create event system | ⚪ | Medium | For communities | | Add polls and surveys | ⚪ | Medium | For engagement | | Implement analytics export | ⚪ | Low | For data portability | | Create developer API | ⚪ | Low | For third-party integration | | Add content moderation | 🔴 | High | Needed before public launch | ## Next Steps 1. Complete the profile editing functionality (P2) 2. Finish the comment system implementation (I5) 3. Complete the bookmark functionality UI (I6) 4. Implement the search functionality (SE1–SE3) 5. Start work on community features (C1, C6) 6. Handle image upload functionality (I7) 7. Fix high priority bugs (B2)
```

# src/docs/Requirements.md

```md
# Social Media Application Requirements Document ## Overview This document details the features, functionalities, and technical specifications for a modern social media application built with React, TypeScript, Next.js, and various supporting technologies. The application is designed to provide users with a seamless experience for content sharing, social interaction, and community engagement. ## Tech Stack ### Frontend - **React** with Next.js App Router for component-based UI development - **TypeScript** for type safety - **Tailwind CSS** for styling - **Radix UI** for accessible UI components - **Recharts** for data visualization - **Lucide React** for icons ### Backend - **Next.js API Routes** for serverless API endpoints - **Prisma ORM** for database queries and operations - **SQLite** as the database engine - **Next Auth** for authentication ### Validation & Type Safety - **Zod** for schema validation and type inference - **TypeScript** for static type checking ### Code Quality - **ESLint** for code linting and best practices enforcement ## Core Features ### 1. User Authentication & Profiles #### Requirements - Email/username and password authentication - Social login support (GitHub, Facebook, Google, Twitter) - User profiles with customizable images, bios, and handles - Follow/unfollow functionality - Follower and following lists #### Technical Details - JWT-based authentication with Next Auth - Secure password storage with bcrypt - Prisma relations for following system - Support for profile image upload ### 2. Left Sidebar Navigation #### Requirements - Collapsible sidebar on the left side of the application - User profile section with profile image, username, and handle - Follower and following counts with links to respective lists - Navigation links to: - Home - Search - Notifications - Messages - Profile - Analytics - Communities - Settings - Dark mode toggle #### Technical Details - Responsive design that collapses to a footer bar on mobile - Context-based state management for sidebar visibility - LocalStorage for persisting user preferences (dark mode) ### 3. Dashboard & Feed #### Requirements - Main content area with various feeds - Floating action button (FAB) for creating new posts - Tab navigation with "For You" and "Following" feeds - User communities displayed as tabs - Auto-hiding tab bar on scroll - Infinite scrolling for content loading #### Technical Details - React context for feed state management - Intersection Observer API for infinite scrolling - Fetch-based API calls for retrieving content - Custom hooks for scroll detection and tab bar visibility ### 4. Content Curation #### Requirements - "For You" feed with content tailored to user interests - "Following" feed showing posts from followed users - Community-specific feeds #### Technical Details - Algorithm for "For You" feed based on: - User interests (communities joined) - Following relationships - Post engagement metrics (likes, comments) - Content recency - Direct query for "Following" feed based on followed user IDs - Community-based filtering for community-specific feeds ### 5. Post Creation & Interaction #### Requirements - Create posts with text (up to 300 characters) - Support for image attachments - Like, comment, and bookmark functionality - Post sharing capabilities - Engagement metrics display (likes, comments, reposts, impressions) #### Technical Details - Modal-based post creation interface - Image upload with preview - Optimistic UI updates for interactions - Real-time character counter ### 6. Advertisements #### Requirements - Interleaved advertisements within the feed - Maximum of one ad per ten posts - Support for ad content, images, and external links #### Technical Details - Ad placement algorithm in feed component - Separate API endpoints for ad retrieval - Ad priority system for targeting ### 7. Analytics #### Requirements - Data visualization for user and content metrics - Charts for follower growth, post engagement, impressions - Content type distribution analytics - Engagement rate calculations #### Technical Details - Recharts for data visualization components - Aggregated data queries for metrics - Responsive chart layouts ### 8. Messaging #### Requirements - Private messaging between users - Conversation list - Real-time message status (read/unread) - Message search functionality #### Technical Details - Conversation-based UI with sender/recipient models - Timestamp formatting with date-fns - Optimistic UI updates for message sending ### 9. Notifications #### Requirements - Notification center for user activities - Support for various notification types: - Likes - Comments - Follows - Mentions - Messages - Ability to mark notifications as read #### Technical Details - Notification model with polymorphic relationships - Read/unread state tracking - Automatic notification generation for relevant actions ### 10. Responsive Design #### Requirements - Desktop and mobile-friendly layouts - Automatic sidebar collapse on smaller screens - Footer navigation bar when sidebar is hidden - Responsive post cards and feed layout #### Technical Details - Tailwind CSS for responsive design - Media queries for specific adaptations - Conditional rendering based on screen size ## Data Models ### Core Models - User - Post - Comment - Like - Bookmark - Follow - Community - Membership - Message - Notification - Advertisement - UserMetrics ### Key Relationships - User-Post: One-to-many - User-Comment: One-to-many - User-Follow: Many-to-many (follower/following) - User-Community: Many-to-many (via Membership) - User-Message: One-to-many (sender/recipient) - User-Notification: One-to-many ## API Endpoints ### Authentication - `/api/auth/signin` - `/api/auth/signup` - `/api/auth/signout` ### Posts - `/api/posts` - CRUD operations - `/api/posts/for-you` - Curated feed - `/api/posts/following` - Following feed - `/api/posts/[id]/like` - Like/unlike - `/api/posts/[id]/bookmark` - Bookmark/unbookmark - `/api/posts/[id]/comment` - Comments ### Communities - `/api/communities` - CRUD operations - `/api/communities/[id]/posts` - Community posts - `/api/communities/user` - User's communities ### Users - `/api/users/[id]` - User details - `/api/users/[id]/follow` - Follow/unfollow - `/api/users/[id]/follow-counts` - Follower/following counts ### Messages - `/api/messages` - Create message - `/api/messages/[userId]` - Get conversation - `/api/messages/conversations` - Get all conversations ### Notifications - `/api/notifications` - Get notifications - `/api/notifications/mark-read` - Mark as read ### Ads - `/api/ads` - Get advertisements ## Technical Constraints ### File Structure & Organization - Maximum file length: 200 lines - Maximum line length: 130 characters - Component-based architecture with clear separation of concerns - Context-based state management - Custom hooks for reusable logic ### Performance Considerations - Lazy loading for images - Pagination and infinite scrolling for feeds - Optimistic updates for user interactions - Efficient re-rendering with proper React practices ### Security Measures - JWT-based authentication - CSRF protection - Input validation with Zod - Secure password storage with bcrypt ### Accessibility - Semantic HTML - ARIA attributes where necessary - Keyboard navigation support - Responsive design for all screen sizes ## Future Considerations ### Scalability - Migration to a more scalable database like PostgreSQL - Implementing Redis for caching - API rate limiting ### Feature Expansion - Direct messaging with real-time capabilities via WebSockets - Content discovery algorithm improvements - Media support expansion (video, audio) - Advanced analytics and insights ### Performance Optimizations - Server-side rendering optimizations - Bundle size reduction - Image optimization ## Deployment Considerations ### Environment Variables - Database connection strings - OAuth provider credentials - API keys for external services ### Build Process - TypeScript compilation - Tailwind CSS optimizations - Bundle analysis ### CI/CD Pipeline - ESLint checks - Type checking - Automated testing - Deployment to hosting platform
```

# src/docs/ProjectStructure.md

```md
Project Structure ├── app/ │ ├── api/ │ │ ├── ads/ │ │ │ └── route.ts │ │ ├── auth/ │ │ │ └── signup/ │ │ │ └── route.ts │ │ ├── communities/ │ │ │ ├── [id]/ │ │ │ │ └── posts/ │ │ │ │ └── route.ts │ │ │ └── user/ │ │ │ └── route.ts │ │ ├── messages/ │ │ │ ├── [userId]/ │ │ │ │ └── route.ts │ │ │ ├── conversations/ │ │ │ │ └── route.ts │ │ │ └── route.ts │ │ ├── notifications/ │ │ │ ├── mark-read/ │ │ │ │ └── route.ts │ │ │ └── route.ts │ │ ├── posts/ │ │ │ ├── [id]/ │ │ │ │ ├── bookmark/ │ │ │ │ │ └── route.ts │ │ │ │ ├── comment/ │ │ │ │ │ └── route.ts │ │ │ │ └── like/ │ │ │ │ └── route.ts │ │ │ ├── following/ │ │ │ │ └── route.ts │ │ │ ├── for-you/ │ │ │ │ └── route.ts │ │ │ └── route.ts │ │ ├── upload/ │ │ │ └── route.ts │ │ └── users/ │ │ ├── [id]/ │ │ │ ├── follow-counts/ │ │ │ │ └── route.ts │ │ │ └── follow/ │ │ │ └── route.ts │ │ └── route.ts │ ├── analytics/ │ │ └── page.tsx │ ├── auth/ │ │ ├── error/ │ │ │ └── page.tsx │ │ ├── signin/ │ │ │ └── page.tsx │ │ └── signup/ │ │ └── page.tsx │ ├── communities/ │ │ └── page.tsx │ ├── followers/ │ │ └── page.tsx │ ├── following/ │ │ └── page.tsx │ ├── globals.css │ ├── layout.tsx │ ├── messages/ │ │ └── page.tsx │ ├── notifications/ │ │ └── page.tsx │ ├── page.tsx │ ├── profile/ │ │ ├── [handle]/ │ │ │ └── page.tsx │ │ └── page.tsx │ ├── search/ │ │ └── page.tsx │ └── settings/ │ └── page.tsx ├── components/ │ ├── feed/ │ │ ├── AdCard.tsx │ │ ├── Feed.tsx │ │ └── TabBar.tsx │ ├── layout/ │ │ ├── MobileFooter.tsx │ │ └── Sidebar.tsx │ ├── post/ │ │ ├── CreatePostModal.tsx │ │ ├── FloatingActionButton.tsx │ │ └── PostCard.tsx │ └── ui/ │ ├── Button.tsx │ ├── Input.tsx │ └── Modal.tsx ├── context/ │ ├── feed-context.tsx │ └── ui-context.tsx ├── hooks/ │ ├── useFollowUser.ts │ ├── useInfiniteScroll.ts │ └── useLocalStorage.ts ├── lib/ │ ├── auth.ts │ ├── db.ts │ ├── utils.ts │ └── validations.ts ├── prisma/ │ ├── migrations/ │ │ └── ... │ └── schema.prisma ├── public/ │ ├── default-avatar.png │ └── logo.svg ├── styles/ │ └── globals.css ├── types/ │ ├── environment.d.ts │ └── next-auth.d.ts ├── .env ├── .env.example ├── .eslintrc.json ├── .gitignore ├── next.config.js ├── package.json ├── README.md ├── tailwind.config.js └── tsconfig.json
```

# src/docs/DevelopmentPlan.md

```md
# Social Media Application Development Plan ## Overview This document outlines the development plan and timeline for building the social media application. The development process is broken down into phases with specific deliverables to ensure incremental progress and allow for testing at each stage. ## Development Phases ### Phase 1: Project Setup and Core Infrastructure (Week 1) **Objective**: Establish the project foundation, basic configuration, and core infrastructure. #### Deliverables: 1. **Project Initialization** - Initialize Next.js project with TypeScript - Configure ESLint and Prettier - Set up Tailwind CSS - Configure directory structure 2. **Database Setup** - Define Prisma schema - Set up migration system - Create initial database migration - Implement database connection utilities 3. **Authentication System** - Implement NextAuth.js integration - Configure credential provider (email/password) - Set up social login providers - Create sign-in and sign-up pages - Implement protected routes 4. **Basic API Structure** - Create API route structure - Implement error handling middleware - Set up API validation with Zod - Create API testing utilities #### Testing Criteria: - User can register with email/password - User can sign in with email/password - User can authenticate using social logins - Protected routes redirect unauthenticated users - API routes enforce authentication where needed ### Phase 2: Core UI Components and Layout (Week 2) **Objective**: Build the primary user interface components and layout structure. #### Deliverables: 1. **Layout Framework** - Implement root layout - Create sidebar component - Build mobile footer navigation - Implement dark mode toggle - Create UI context provider 2. **Common UI Components** - Build button component - Create input and form elements - Implement modal component - Design card components - Create loading states 3. **User Profile Components** - Build profile header - Create follower/following display - Implement user avatar component - Design profile edit interface 4. **Navigation Features** - Implement sidebar collapse functionality - Create responsive navigation system - Build auto-hiding tab bar - Implement route change handling #### Testing Criteria: - Layout adapts correctly to different screen sizes - Sidebar collapses and expands as expected - Dark mode toggle works properly - UI components are accessible and responsive - Navigation works correctly across routes ### Phase 3: Post Creation and Feed Implementation (Week 3) **Objective**: Implement the core content features - post creation and feed display. #### Deliverables: 1. **Post Creation** - Build post composition modal - Implement character counter - Create image upload functionality - Design post creation form - Implement post submission API 2. **Feed Structure** - Create feed context provider - Build tab bar component for feed types - Implement feed container - Create post card component - Build loading and error states 3. **Feed Algorithms** - Implement "For You" algorithm - Create "Following" feed logic - Build community-specific feeds - Design feed caching strategy 4. **Infinite Scrolling** - Implement infinite scroll hook - Create pagination logic - Build scroll position tracking - Design load-more functionality #### Testing Criteria: - Users can create posts with text and images - Posts appear correctly in feeds - Character limit is enforced - Different feed types display appropriate content - Infinite scrolling loads additional content - Feed tabs switch content correctly ### Phase 4: Social Interactions and Content Engagement (Week 4) **Objective**: Implement social features and post interaction functionality. #### Deliverables: 1. **Post Interactions** - Build like functionality - Implement comment system - Create bookmark feature - Design share functionality - Implement post metrics display 2. **Follow System** - Build user follow/unfollow API - Implement follower/following lists - Create follow button component - Design follow recommendation algorithm 3. **Engagement Tracking** - Implement impression tracking - Create engagement metrics - Build content popularity algorithm - Design content relevance scoring 4. **Notifications System** - Create notification model - Build notification generation - Implement notification center - Design real-time notification updates #### Testing Criteria: - Users can like, comment, and bookmark posts - Follow/unfollow functionality works correctly - Engagement metrics are tracked properly - Notifications are generated for relevant actions - Notification center displays all user activities ### Phase 5: Communities and Advanced Features (Week 5) **Objective**: Implement community features and advanced social capabilities. #### Deliverables: 1. **Communities System** - Build community model and API - Create community discovery page - Implement community join/leave functionality - Design community feed integration - Build community management features 2. **Messaging System** - Implement conversation model - Create messaging interface - Build message list component - Design conversation management - Implement message search 3. **Advertisement Integration** - Create advertisement model - Build ad placement algorithm - Implement ad card component - Design ad targeting logic 4. **Search Functionality** - Implement user search - Create content search - Build community search - Design search results display #### Testing Criteria: - Users can create, join, and leave communities - Community content appears in feeds - Messaging works between users - Ads appear appropriately in feeds - Search returns relevant results for users, posts, and communities ### Phase 6: Analytics and Refinement (Week 6) **Objective**: Implement analytics features and refine the application. #### Deliverables: 1. **Analytics Dashboard** - Build analytics page layout - Implement data visualization components - Create metrics calculation utilities - Design user insights generation 2. **Performance Optimization** - Implement code splitting - Optimize image loading - Refine database queries - Reduce bundle size 3. **Polish and Refinement** - Implement comprehensive error handling - Refine animations and transitions - Create skeleton loading states - Design empty states for all views 4. **Documentation** - Complete user guide - Finalize technical documentation - Create API documentation - Design onboarding flows #### Testing Criteria: - Analytics dashboard correctly displays user metrics - Application performs well under load - Error states are handled gracefully - Documentation is comprehensive and accurate - UI is polished and responsive ## Timeline and Milestones ### Week 1: Project Setup and Authentication - **Day 1-2**: Project initialization and configuration - **Day 3-4**: Database setup and initial models - **Day 5-7**: Authentication system implementation ### Week 2: Core UI and Layout - **Day 8-9**: Layout framework implementation - **Day 10-11**: Common UI component development - **Day 12-14**: Navigation and profile components ### Week 3: Posts and Feeds - **Day 15-16**: Post creation functionality - **Day 17-18**: Feed structure and algorithms - **Day 19-21**: Infinite scrolling and feed optimization ### Week 4: Social Features - **Day 22-23**: Post interactions implementation - **Day 24-25**: Follow system and engagement tracking - **Day 26-28**: Notifications system ### Week 5: Advanced Features - **Day 29-30**: Communities implementation - **Day 31-32**: Messaging system - **Day 33-35**: Ads and search functionality ### Week 6: Polishing and Finalization - **Day 36-37**: Analytics dashboard - **Day 38-39**: Performance optimization - **Day 40-42**: Final refinements and documentation ## Resource Allocation ### Development Team - 1 Full-stack developer (lead) - 1 Frontend specialist - 1 Backend specialist - 1 UI/UX designer (part-time) - 1 QA engineer (part-time) ### Technology Stack - **Frontend**: React, TypeScript, Next.js, Tailwind CSS, Radix UI - **Backend**: Next.js API Routes, Prisma ORM - **Database**: SQLite (development), PostgreSQL (production) - **DevOps**: GitHub Actions, Vercel ## Risk Management ### Identified Risks and Mitigation Strategies 1. **Technical Complexity** - **Risk**: Features like real-time messaging and notifications may be complex to implement - **Mitigation**: Start with simpler polling approaches, then enhance with WebSockets if time permits 2. **Performance Issues** - **Risk**: Feed rendering and infinite scrolling may cause performance problems - **Mitigation**: Implement virtualization and proper component memoization early 3. **Scope Creep** - **Risk**: Additional feature requests may delay completion - **Mitigation**: Strict prioritization and minimum viable product definition 4. **Integration Challenges** - **Risk**: Third-party services (OAuth providers) may require additional configuration - **Mitigation**: Set up and test integrations early in the development process ## Quality Assurance ### Testing Strategy 1. **Unit Testing** - Test all utility functions and hooks - Implement component unit tests for core UI elements - Ensure at least 80% test coverage for critical functions 2. **Integration Testing** - Test API endpoints - Verify database operations - Validate authentication flows 3. **End-to-End Testing** - Test critical user journeys - Verify multi-step processes - Test responsive behavior 4. **Performance Testing** - Measure and optimize load times - Test infinite scrolling performance - Validate database query performance ## Deployment Strategy ### Environments 1. **Development**: Local development environment 2. **Staging**: Production-like environment for testing 3. **Production**: Live environment for end users ### Deployment Process 1. Code review and PR approval 2. Automated tests in CI pipeline 3. Deployment to staging environment 4. Manual QA verification 5. Deployment to production environment 6. Post-deployment verification ## Conclusion This development plan provides a structured approach to building the social media application over a 6-week period. By breaking the project into manageable phases with clear deliverables, we can ensure steady progress and quality at each step. The plan accommodates for potential risks and emphasizes early testing to identify and resolve issues promptly.
```

# src/docs/Best Practise.md

```md
- 🔁 **Reusable**: Build once, use anywhere in the app - 🧩 **Modular**: Break UI into small, manageable pieces (under 100 lines of code is ideal. Fell free to use directories to organise[e.g. Instead of having one huge file with all uitility functions, create a utils dir and put associated groups of functions in their own file]) - 🧠 **Separation of Concerns**: Logic and presentation stay cleanly divided - ⚡ **Efficient**: Virtual DOM boosts rendering performance - 🔧 **Maintainable**: Easier to debug and update in isolation - 📈 **Scalable**: Ideal for growing, team-based projects - 🎨 **Consistent**: Uniform look and behavior across the app - 🧪 **Testable**: Components can be tested independently - 🤝 **Collaborative**: Multiple devs can work in parallel on different components
```

# src/app/page.tsx

```tsx
'use client'; import { Suspense } from 'react'; import { FeedProvider } from '@/context/feed-context'; import TabBar from '@/components/feed/TabBar'; import Feed from '@/components/feed/Feed'; import FloatingActionButton from '@/components/post/FloatingActionButton'; import { Loader2 } from 'lucide-react'; export default function DashboardPage() { return ( <FeedProvider> <div className="pb-16 md:pb-0"> {/* Tab Bar */} <TabBar /> {/* Main Content */} <div className="max-w-2xl mx-auto"> <Suspense fallback={ <div className="flex justify-center items-center h-64"> <Loader2 className="h-8 w-8 animate-spin text-blue-500" /> </div> }> <Feed /> </Suspense> </div> {/* Floating Action Button */} <FloatingActionButton /> </div> </FeedProvider> ); }
```

# src/app/layout.tsx

```tsx
// src/app/layout.tsx import './globals.css'; import { Inter } from 'next/font/google'; import type { Metadata } from 'next'; import { ReactNode } from 'react'; import { getServerSession } from 'next-auth/next'; import AuthProvider from '@/components/providers/AuthProvider'; import { UIProvider } from '@/context/ui-context'; import ClientLayout from '@/components/layout/ClientLayout'; import { authOptions } from '@/lib/auth'; const inter = Inter({ subsets: ['latin'] }); export const metadata: Metadata = { title: 'SocialApp', description: 'A social media application built with Next.js and TypeScript', }; interface RootLayoutProps { children: ReactNode; } export default async function RootLayout({ children }: RootLayoutProps) { const session = await getServerSession(authOptions); return ( <html lang="en"> <head> <title>SocialApp</title> <meta name="viewport" content="width=device-width, initial-scale=1" /> </head> <body> <AuthProvider session={session}> <UIProvider> <ClientLayout>{children}</ClientLayout> </UIProvider> </AuthProvider> </body> </html> ); }
```

# src/app/globals.css

```css
@import "tailwindcss"; :root { --background: #ffffff; --foreground: #171717; } @theme inline { --color-background: var(--background); --color-foreground: var(--foreground); --font-sans: var(--font-geist-sans); --font-mono: var(--font-geist-mono); } @media (prefers-color-scheme: dark) { :root { --background: #0a0a0a; --foreground: #ededed; } } body { background: var(--background); color: var(--foreground); font-family: Arial, Helvetica, sans-serif; }
```

# src/app/favicon.ico

This is a binary file of the type: Binary

# prisma/migrations/20250416230925_init/migration.sql

```sql
-- CreateTable CREATE TABLE "User" ( "id" TEXT NOT NULL PRIMARY KEY, "email" TEXT NOT NULL, "username" TEXT NOT NULL, "handle" TEXT NOT NULL, "password" TEXT, "profileImage" TEXT, "bio" TEXT, "createdAt" DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP, "updatedAt" DATETIME NOT NULL ); -- CreateTable CREATE TABLE "UserMetrics" ( "id" TEXT NOT NULL PRIMARY KEY, "userId" TEXT NOT NULL, "impressionsCount" INTEGER NOT NULL DEFAULT 0, "followersGrowth" INTEGER NOT NULL DEFAULT 0, "postEngagement" REAL NOT NULL DEFAULT 0, "updatedAt" DATETIME NOT NULL, CONSTRAINT "UserMetrics_userId_fkey" FOREIGN KEY ("userId") REFERENCES "User" ("id") ON DELETE CASCADE ON UPDATE CASCADE ); -- CreateTable CREATE TABLE "Post" ( "id" TEXT NOT NULL PRIMARY KEY, "text" TEXT NOT NULL, "images" TEXT, "authorId" TEXT NOT NULL, "createdAt" DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP, "updatedAt" DATETIME NOT NULL, "impressions" INTEGER NOT NULL DEFAULT 0, "communityId" TEXT, CONSTRAINT "Post_authorId_fkey" FOREIGN KEY ("authorId") REFERENCES "User" ("id") ON DELETE CASCADE ON UPDATE CASCADE, CONSTRAINT "Post_communityId_fkey" FOREIGN KEY ("communityId") REFERENCES "Community" ("id") ON DELETE SET NULL ON UPDATE CASCADE ); -- CreateTable CREATE TABLE "Comment" ( "id" TEXT NOT NULL PRIMARY KEY, "text" TEXT NOT NULL, "postId" TEXT NOT NULL, "authorId" TEXT NOT NULL, "createdAt" DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP, "updatedAt" DATETIME NOT NULL, CONSTRAINT "Comment_postId_fkey" FOREIGN KEY ("postId") REFERENCES "Post" ("id") ON DELETE CASCADE ON UPDATE CASCADE, CONSTRAINT "Comment_authorId_fkey" FOREIGN KEY ("authorId") REFERENCES "User" ("id") ON DELETE CASCADE ON UPDATE CASCADE ); -- CreateTable CREATE TABLE "Like" ( "id" TEXT NOT NULL PRIMARY KEY, "postId" TEXT NOT NULL, "userId" TEXT NOT NULL, "createdAt" DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP, CONSTRAINT "Like_postId_fkey" FOREIGN KEY ("postId") REFERENCES "Post" ("id") ON DELETE CASCADE ON UPDATE CASCADE, CONSTRAINT "Like_userId_fkey" FOREIGN KEY ("userId") REFERENCES "User" ("id") ON DELETE CASCADE ON UPDATE CASCADE ); -- CreateTable CREATE TABLE "Bookmark" ( "id" TEXT NOT NULL PRIMARY KEY, "postId" TEXT NOT NULL, "userId" TEXT NOT NULL, "createdAt" DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP, CONSTRAINT "Bookmark_postId_fkey" FOREIGN KEY ("postId") REFERENCES "Post" ("id") ON DELETE CASCADE ON UPDATE CASCADE, CONSTRAINT "Bookmark_userId_fkey" FOREIGN KEY ("userId") REFERENCES "User" ("id") ON DELETE CASCADE ON UPDATE CASCADE ); -- CreateTable CREATE TABLE "Follow" ( "id" TEXT NOT NULL PRIMARY KEY, "followerId" TEXT NOT NULL, "followingId" TEXT NOT NULL, "createdAt" DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP, CONSTRAINT "Follow_followerId_fkey" FOREIGN KEY ("followerId") REFERENCES "User" ("id") ON DELETE CASCADE ON UPDATE CASCADE, CONSTRAINT "Follow_followingId_fkey" FOREIGN KEY ("followingId") REFERENCES "User" ("id") ON DELETE CASCADE ON UPDATE CASCADE ); -- CreateTable CREATE TABLE "Community" ( "id" TEXT NOT NULL PRIMARY KEY, "name" TEXT NOT NULL, "description" TEXT, "image" TEXT, "createdAt" DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP, "updatedAt" DATETIME NOT NULL ); -- CreateTable CREATE TABLE "Membership" ( "id" TEXT NOT NULL PRIMARY KEY, "userId" TEXT NOT NULL, "communityId" TEXT NOT NULL, "role" TEXT NOT NULL DEFAULT 'member', "createdAt" DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP, CONSTRAINT "Membership_userId_fkey" FOREIGN KEY ("userId") REFERENCES "User" ("id") ON DELETE CASCADE ON UPDATE CASCADE, CONSTRAINT "Membership_communityId_fkey" FOREIGN KEY ("communityId") REFERENCES "Community" ("id") ON DELETE CASCADE ON UPDATE CASCADE ); -- CreateTable CREATE TABLE "Message" ( "id" TEXT NOT NULL PRIMARY KEY, "content" TEXT NOT NULL, "senderId" TEXT NOT NULL, "recipientId" TEXT NOT NULL, "read" BOOLEAN NOT NULL DEFAULT false, "createdAt" DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP, CONSTRAINT "Message_senderId_fkey" FOREIGN KEY ("senderId") REFERENCES "User" ("id") ON DELETE CASCADE ON UPDATE CASCADE, CONSTRAINT "Message_recipientId_fkey" FOREIGN KEY ("recipientId") REFERENCES "User" ("id") ON DELETE CASCADE ON UPDATE CASCADE ); -- CreateTable CREATE TABLE "Notification" ( "id" TEXT NOT NULL PRIMARY KEY, "type" TEXT NOT NULL, "read" BOOLEAN NOT NULL DEFAULT false, "userId" TEXT NOT NULL, "sourceId" TEXT, "postId" TEXT, "message" TEXT, "createdAt" DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP, CONSTRAINT "Notification_userId_fkey" FOREIGN KEY ("userId") REFERENCES "User" ("id") ON DELETE CASCADE ON UPDATE CASCADE, CONSTRAINT "Notification_sourceId_fkey" FOREIGN KEY ("sourceId") REFERENCES "User" ("id") ON DELETE SET NULL ON UPDATE CASCADE ); -- CreateTable CREATE TABLE "Advertisement" ( "id" TEXT NOT NULL PRIMARY KEY, "title" TEXT NOT NULL, "content" TEXT NOT NULL, "imageUrl" TEXT, "link" TEXT, "active" BOOLEAN NOT NULL DEFAULT true, "priority" INTEGER NOT NULL DEFAULT 0, "createdAt" DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP, "updatedAt" DATETIME NOT NULL ); -- CreateIndex CREATE UNIQUE INDEX "User_email_key" ON "User"("email"); -- CreateIndex CREATE UNIQUE INDEX "User_username_key" ON "User"("username"); -- CreateIndex CREATE UNIQUE INDEX "User_handle_key" ON "User"("handle"); -- CreateIndex CREATE UNIQUE INDEX "UserMetrics_userId_key" ON "UserMetrics"("userId"); -- CreateIndex CREATE UNIQUE INDEX "Like_postId_userId_key" ON "Like"("postId", "userId"); -- CreateIndex CREATE UNIQUE INDEX "Bookmark_postId_userId_key" ON "Bookmark"("postId", "userId"); -- CreateIndex CREATE UNIQUE INDEX "Follow_followerId_followingId_key" ON "Follow"("followerId", "followingId"); -- CreateIndex CREATE UNIQUE INDEX "Community_name_key" ON "Community"("name"); -- CreateIndex CREATE UNIQUE INDEX "Membership_userId_communityId_key" ON "Membership"("userId", "communityId");
```

# src/app/notifications/page.tsx

```tsx
'use client'; import { useState, useEffect } from 'react'; import { useSession } from 'next-auth/react'; import Image from 'next/image'; import Link from 'next/link'; import { formatDistanceToNow } from 'date-fns'; import { Loader2, Heart, MessageSquare, UserPlus, AtSign, Bell } from 'lucide-react'; import { Notification } from '@/lib/validations'; interface NotificationWithDetails extends Notification { sourceUser?: { id: string; username: string; handle: string; profileImage: string | null; }; postText?: string; } export default function NotificationsPage() { const { data: session, status } = useSession(); const [notifications, setNotifications] = useState<NotificationWithDetails[]>([]); const [loading, setLoading] = useState(true); const [error, setError] = useState<string | null>(null); useEffect(() => { if (status === 'authenticated') { fetchNotifications(); } }, [status]); const fetchNotifications = async () => { try { setLoading(true); const response = await fetch('/api/notifications'); if (!response.ok) { throw new Error('Failed to fetch notifications'); } const data = await response.json(); setNotifications(data); // Mark all as read if (data.some((notification: Notification) => !notification.read)) { await fetch('/api/notifications/mark-read', { method: 'POST', }); } } catch (err) { setError('Failed to load notifications'); console.error(err); } finally { setLoading(false); } }; // For demo purposes, generate sample notifications if API not implemented useEffect(() => { if (status === 'authenticated' && loading) { // Sample notifications const sampleNotifications: NotificationWithDetails[] = [ { id: '1', type: 'like', read: false, userId: session.user.id, sourceId: 'user1', postId: 'post1', createdAt: new Date(Date.now() - 1000 * 60 * 5).toISOString(), // 5 minutes ago sourceUser: { id: 'user1', username: 'Jane Smith', handle: '@janesmith', profileImage: 'https://i.pravatar.cc/150?img=1', }, postText: 'Just launched my new project! Check it out and let me know what you think.', }, { id: '2', type: 'follow', read: false, userId: session.user.id, sourceId: 'user2', createdAt: new Date(Date.now() - 1000 * 60 * 30).toISOString(), // 30 minutes ago sourceUser: { id: 'user2', username: 'John Doe', handle: '@johndoe', profileImage: 'https://i.pravatar.cc/150?img=2', }, }, { id: '3', type: 'comment', read: true, userId: session.user.id, sourceId: 'user3', postId: 'post2', message: 'This is really insightful! Thanks for sharing.', createdAt: new Date(Date.now() - 1000 * 60 * 60 * 2).toISOString(), // 2 hours ago sourceUser: { id: 'user3', username: 'Alex Johnson', handle: '@alexj', profileImage: 'https://i.pravatar.cc/150?img=3', }, postText: 'Here are my thoughts on the latest tech trends for 2025...', }, { id: '4', type: 'mention', read: true, userId: session.user.id, sourceId: 'user4', postId: 'post3', createdAt: new Date(Date.now() - 1000 * 60 * 60 * 24).toISOString(), // 1 day ago sourceUser: { id: 'user4', username: 'Sarah Williams', handle: '@sarahw', profileImage: 'https://i.pravatar.cc/150?img=4', }, postText: `Hey ${session?.user.handle}, what do you think about this new feature?`, }, { id: '5', type: 'message', read: true, userId: session.user.id, sourceId: 'user5', message: 'Could we discuss a potential collaboration?', createdAt: new Date(Date.now() - 1000 * 60 * 60 * 48).toISOString(), // 2 days ago sourceUser: { id: 'user5', username: 'Michael Brown', handle: '@michaelb', profileImage: 'https://i.pravatar.cc/150?img=5', }, }, ]; setNotifications(sampleNotifications); setLoading(false); } }, [status, loading, session?.user]); const getNotificationIcon = (type: string) => { switch (type) { case 'like': return <Heart size={16} className="text-red-500" />; case 'comment': return <MessageSquare size={16} className="text-blue-500" />; case 'follow': return <UserPlus size={16} className="text-green-500" />; case 'mention': return <AtSign size={16} className="text-purple-500" />; case 'message': return <MessageSquare size={16} className="text-blue-500" />; default: return <Bell size={16} className="text-gray-500" />; } }; const getNotificationContent = (notification: NotificationWithDetails) => { switch (notification.type) { case 'like': return ( <> <span className="font-bold">{notification.sourceUser?.username}</span> liked your post </> ); case 'comment': return ( <> <span className="font-bold">{notification.sourceUser?.username}</span> commented on your post: <span className="block mt-1 text-gray-600 dark:text-gray-400 text-sm"> {notification.message} </span> </> ); case 'follow': return ( <> <span className="font-bold">{notification.sourceUser?.username}</span> followed you </> ); case 'mention': return ( <> <span className="font-bold">{notification.sourceUser?.username}</span> mentioned you in a post </> ); case 'message': return ( <> <span className="font-bold">{notification.sourceUser?.username}</span> sent you a message: <span className="block mt-1 text-gray-600 dark:text-gray-400 text-sm"> {notification.message} </span> </> ); default: return <span>New notification</span>; } }; const getNotificationLink = (notification: NotificationWithDetails) => { switch (notification.type) { case 'like': case 'comment': case 'mention': return notification.postId ? `/post/${notification.postId}` : '#'; case 'follow': return notification.sourceUser ? `/profile/${notification.sourceUser.handle}` : '#'; case 'message': return '/messages'; default: return '#'; } }; if (status === 'loading' || loading) { return ( <div className="flex justify-center items-center h-64"> <Loader2 className="h-8 w-8 animate-spin text-blue-500" /> </div> ); } if (status === 'unauthenticated') { return ( <div className="max-w-4xl mx-auto p-6 text-center"> <h1 className="text-2xl font-bold mb-4">Sign in to view notifications</h1> <p>You need to be signed in to access this page.</p> </div> ); } return ( <div className="max-w-2xl mx-auto p-4 pb-16 md:pb-4"> <h1 className="text-2xl font-bold mb-6">Notifications</h1> {error && ( <div className="bg-red-100 dark:bg-red-900 p-4 rounded-lg text-red-600 dark:text-red-200 mb-4"> {error} </div> )} {notifications.length === 0 ? ( <div className="bg-white dark:bg-gray-800 rounded-lg p-6 text-center shadow"> <Bell size={40} className="mx-auto mb-4 text-gray-400" /> <h2 className="text-xl font-semibold mb-2">No notifications yet</h2> <p className="text-gray-500 dark:text-gray-400"> When you get notifications, they'll appear here. </p> </div> ) : ( <div className="bg-white dark:bg-gray-800 rounded-lg shadow divide-y divide-gray-200 dark:divide-gray-700"> {notifications.map((notification) => ( <Link key={notification.id} href={getNotificationLink(notification)} className={`block p-4 hover:bg-gray-50 dark:hover:bg-gray-700 transition-colors ${!notification.read ? 'bg-blue-50 dark:bg-blue-900/20' : ''}`} > <div className="flex items-start"> {notification.sourceUser?.profileImage ? ( <Image src={notification.sourceUser.profileImage} alt={notification.sourceUser.username} width={48} height={48} className="rounded-full mr-4" /> ) : ( <div className="w-12 h-12 bg-gray-200 dark:bg-gray-700 rounded-full mr-4 flex items-center justify-center"> {getNotificationIcon(notification.type)} </div> )} <div className="flex-1 min-w-0"> <div className="flex justify-between items-start"> <div className="text-sm sm:text-base">{getNotificationContent(notification)}</div> {!notification.read && ( <div className="ml-2 h-2 w-2 bg-blue-500 rounded-full"></div> )} </div> {notification.postText && ( <div className="mt-2 p-3 rounded bg-gray-100 dark:bg-gray-700 text-sm"> {notification.postText} </div> )} <div className="mt-1 text-xs text-gray-500 dark:text-gray-400"> {formatDistanceToNow(new Date(notification.createdAt), { addSuffix: true })} </div> </div> </div> </Link> ))} </div> )} </div> ); }
```

# src/app/profile/page.tsx

```tsx
// src/app/profile/page.tsx 'use client'; import { useSession } from 'next-auth/react'; import { useRouter } from 'next/navigation'; import { useEffect } from 'react'; export default function ProfileIndexRedirect() { const { data: session, status } = useSession(); const router = useRouter(); useEffect(() => { // 1. Still loading the session → do nothing if (status === 'loading') return; // 2. Not signed in → go to sign-in if (status === 'unauthenticated' || !session?.user) { router.replace('/auth/signin'); return; } // 3. Signed in but no handle → send to settings const handle = session.user.handle; if (!handle) { console.error('No handle in session.user:', session.user); router.replace('/settings'); return; } // 4. Valid handle → go to your profile router.replace(`/profile/${handle}`); }, [session, status, router]); return null; }
```

# src/app/messages/page.tsx

```tsx
// src/app/messages/page.tsx 'use client'; import { useState, useEffect, useRef } from 'react'; import { useSession } from 'next-auth/react'; import Image from 'next/image'; import { Loader2, Send, Search, MoreVertical } from 'lucide-react'; import { formatDistanceToNow } from 'date-fns'; import { Message } from '@/lib/validations'; interface Conversation { id: string; userId: string; username: string; handle: string; profileImage: string | null; lastMessage: string; timestamp: string; unread: boolean; } interface MessageWithUser extends Message { sender: { id: string; username: string; handle: string; profileImage: string | null; }; } export default function MessagesPage() { const { data: session, status } = useSession(); const [conversations, setConversations] = useState<Conversation[]>([]); const [activeConversation, setActiveConversation] = useState<Conversation | null>(null); const [messages, setMessages] = useState<MessageWithUser[]>([]); const [newMessage, setNewMessage] = useState(''); const [loading, setLoading] = useState(true); const [sendingMessage, setSendingMessage] = useState(false); const [error, setError] = useState<string | null>(null); const [searchQuery, setSearchQuery] = useState(''); const messagesEndRef = useRef<HTMLDivElement>(null); // Fetch conversations when component mounts useEffect(() => { if (status === 'authenticated') { fetchConversations(); } }, [status]); // Fetch messages when active conversation changes useEffect(() => { if (activeConversation) { fetchMessages(activeConversation.userId); } }, [activeConversation]); // Scroll to bottom of messages useEffect(() => { messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' }); }, [messages]); // For demo purposes, generate sample conversations if API is not implemented useEffect(() => { if (status === 'authenticated' && loading) { // Sample conversations const sampleConversations: Conversation[] = [ { id: '1', userId: 'user1', username: 'Jane Smith', handle: '@janesmith', profileImage: 'https://i.pravatar.cc/150?img=1', lastMessage: 'Hey, how are you doing?', timestamp: new Date(Date.now() - 1000 * 60 * 5).toISOString(), // 5 minutes ago unread: true, }, { id: '2', userId: 'user2', username: 'John Doe', handle: '@johndoe', profileImage: 'https://i.pravatar.cc/150?img=2', lastMessage: 'Did you see the latest post?', timestamp: new Date(Date.now() - 1000 * 60 * 60 * 2).toISOString(), // 2 hours ago unread: false, }, { id: '3', userId: 'user3', username: 'Alex Johnson', handle: '@alexj', profileImage: 'https://i.pravatar.cc/150?img=3', lastMessage: 'Thanks for sharing that article!', timestamp: new Date(Date.now() - 1000 * 60 * 60 * 24).toISOString(), // 1 day ago unread: false, }, ]; setConversations(sampleConversations); setLoading(false); // Set first conversation as active if (sampleConversations.length > 0) { setActiveConversation(sampleConversations[0]); } } }, [status, loading]); const fetchConversations = async () => { try { setLoading(true); const response = await fetch('/api/messages/conversations'); if (!response.ok) { throw new Error('Failed to fetch conversations'); } const data = await response.json(); setConversations(data); // Set first conversation as active if (data.length > 0) { setActiveConversation(data[0]); } } catch (err) { setError('Failed to load conversations'); console.error(err); } finally { setLoading(false); } }; const fetchMessages = async (userId: string) => { try { setLoading(true); const response = await fetch(`/api/messages/${userId}`); if (!response.ok) { throw new Error('Failed to fetch messages'); } const data = await response.json(); setMessages(data); // Mark conversation as read setConversations(prev => prev.map(conv => conv.userId === userId ? { ...conv, unread: false } : conv ) ); } catch (err) { setError('Failed to load messages'); console.error(err); } finally { setLoading(false); } }; // For demo purposes, generate sample messages if API is not implemented useEffect(() => { if (activeConversation && messages.length === 0) { // Sample messages const sampleMessages: MessageWithUser[] = [ { id: '1', content: 'Hey there!', senderId: activeConversation.userId, recipientId: session?.user.id || '', read: true, createdAt: new Date(Date.now() - 1000 * 60 * 30), // 30 minutes ago sender: { id: activeConversation.userId, username: activeConversation.username, handle: activeConversation.handle, profileImage: activeConversation.profileImage, }, }, { id: '2', content: 'Hi! How are you doing?', senderId: session?.user.id || '', recipientId: activeConversation.userId, read: true, createdAt: new Date(Date.now() - 1000 * 60 * 29), // 29 minutes ago sender: { id: session?.user.id || '', username: session?.user.username || '', handle: session?.user.handle || '', profileImage: session?.user.image || null, }, }, { id: '3', content: 'I\'m good, thanks! Just checking out the new features on the platform.Have you seen the new analytics page?', senderId: activeConversation.userId, recipientId: session?.user.id || '', read: true, createdAt: new Date(Date.now() - 1000 * 60 * 25), // 25 minutes ago sender: { id: activeConversation.userId, username: activeConversation.username, handle: activeConversation.handle, profileImage: activeConversation.profileImage, }, }, { id: '4', content: 'Not yet, I\'ll have to check it out.I\'ve been busy working on a new post.', senderId: session?.user.id || '', recipientId: activeConversation.userId, read: true, createdAt: new Date(Date.now() - 1000 * 60 * 20), // 20 minutes ago sender: { id: session?.user.id || '', username: session?.user.username || '', handle: session?.user.handle || '', profileImage: session?.user.image || null, }, }, ]; setMessages(sampleMessages); } }, [activeConversation, messages.length, session?.user]); const handleSendMessage = async (e: React.FormEvent) => { e.preventDefault(); if (!session?.user || !activeConversation || !newMessage.trim()) { return; } try { setSendingMessage(true); // Create new message object const messageData = { content: newMessage, recipientId: activeConversation.userId, }; // In a real implementation, send to API const response = await fetch('/api/messages', { method: 'POST', headers: { 'Content-Type': 'application/json', }, body: JSON.stringify(messageData), }); if (!response.ok) { throw new Error('Failed to send message'); } // For demo purposes, add message locally const newMsg: MessageWithUser = { id: `temp-${Date.now()}`, content: newMessage, senderId: session.user.id, recipientId: activeConversation.userId, read: false, createdAt: new Date(), sender: { id: session.user.id, username: session.user.username, handle: session.user.handle, profileImage: session.user.image || null, }, }; setMessages(prev => [...prev, newMsg]); // Update last message in conversation list setConversations(prev => prev.map(conv => conv.userId === activeConversation.userId ? { ...conv, lastMessage: newMessage, timestamp: new Date().toISOString(), } : conv ) ); // Clear input setNewMessage(''); } catch (err) { setError('Failed to send message: '+error); console.error(err); } finally { setSendingMessage(false); } }; // Filter conversations based on search query const filteredConversations = conversations.filter( conv => conv.username.toLowerCase().includes(searchQuery.toLowerCase()) || conv.handle.toLowerCase().includes(searchQuery.toLowerCase()) ); if (status === 'loading') { return ( <div className="flex justify-center items-center h-screen"> <Loader2 className="h-8 w-8 animate-spin text-blue-500" /> </div> ); } if (status === 'unauthenticated') { return ( <div className="max-w-4xl mx-auto p-6 text-center"> <h1 className="text-2xl font-bold mb-4">Sign in to access messages</h1> <p>You need to be signed in to use this feature.</p> </div> ); } return ( <div className="h-[calc(100vh-4rem)]"> <div className="flex h-full"> {/* Conversations sidebar */} <div className="w-full md:w-80 border-r border-gray-200 dark:border-gray-700 flex flex-col h-full"> <div className="p-4 border-b border-gray-200 dark:border-gray-700"> <div className="relative"> <Search className="absolute left-3 top-1/2 transform -translate-y-1/2 text-gray-400" size={18} /> <input type="text" placeholder="Search messages" value={searchQuery} onChange={(e) => setSearchQuery(e.target.value)} className="w-full pl-10 pr-4 py-2 border border-gray-300 dark:border-gray-600 rounded-full bg-gray-100 dark:bg-gray-700" /> </div> </div> <div className="flex-1 overflow-y-auto"> {loading && conversations.length === 0 ? ( <div className="flex justify-center items-center h-full"> <Loader2 className="h-6 w-6 animate-spin text-blue-500" /> </div> ) : filteredConversations.length === 0 ? ( <div className="p-4 text-center text-gray-500"> {searchQuery ? 'No conversations match your search' : 'No conversations yet'} </div> ) : ( filteredConversations.map((conversation) => ( <button key={conversation.id} onClick={() => setActiveConversation(conversation)} className={`w-full text-left p-3 hover:bg-gray-100 dark:hover:bg-gray-700 flex items-start space-x-3 ${activeConversation?.id === conversation.id ? 'bg-gray-100 dark:bg-gray-700' : '' }`} > <div className="relative flex-shrink-0"> <Image src={conversation.profileImage || '/default-avatar.png'} alt={conversation.username} width={50} height={50} className="rounded-full" /> {conversation.unread && ( <span className="absolute top-0 right-0 block h-3 w-3 rounded-full bg-blue-500" /> )} </div> <div className="flex-1 min-w-0"> <div className="flex justify-between items-baseline"> <h3 className="font-medium truncate">{conversation.username}</h3> <span className="text-xs text-gray-500"> {formatDistanceToNow(new Date(conversation.timestamp), { addSuffix: true })} </span> </div> <p className="text-sm text-gray-500 dark:text-gray-400 truncate"> {conversation.lastMessage} </p> </div> </button> )) )} </div> </div> {/* Message content */} <div className="hidden md:flex flex-col flex-1 h-full"> {activeConversation ? ( <> {/* Conversation header */} <div className="p-4 border-b border-gray-200 dark:border-gray-700 flex items-center justify-between"> <div className="flex items-center"> <Image src={activeConversation.profileImage || '/default-avatar.png'} alt={activeConversation.username} width={40} height={40} className="rounded-full mr-3" /> <div> <h3 className="font-medium">{activeConversation.username}</h3> <p className="text-sm text-gray-500 dark:text-gray-400"> {activeConversation.handle} </p> </div> </div> <button className="p-2 rounded-full hover:bg-gray-100 dark:hover:bg-gray-700"> <MoreVertical size={20} /> </button> </div> {/* Messages */} <div className="flex-1 overflow-y-auto p-4 space-y-4"> {messages.map((message) => ( <div key={message.id} className={`flex ${message.senderId === session?.user.id ? 'justify-end' : 'justify-start' }`} > <div className={`max-w-[70%] p-3 rounded-lg ${message.senderId === session?.user.id ? 'bg-blue-500 text-white rounded-br-none' : 'bg-gray-100 dark:bg-gray-700 rounded-bl-none' }`} > <p>{message.content}</p> <div className={`text-xs mt-1 ${message.senderId === session?.user.id ? 'text-blue-100' : 'text-gray-500' }`} > {formatDistanceToNow(new Date(message.createdAt), { addSuffix: true })} </div> </div> </div> ))} <div ref={messagesEndRef} /> </div> {/* Message input */} <div className="p-4 border-t border-gray-200 dark:border-gray-700"> <form onSubmit={handleSendMessage} className="flex items-center space-x-2"> <input type="text" placeholder="Type a message..." value={newMessage} onChange={(e) => setNewMessage(e.target.value)} className="flex-1 p-2 border border-gray-300 dark:border-gray-600 rounded-full bg-gray-100 dark:bg-gray-700" disabled={sendingMessage} /> <button type="submit" disabled={!newMessage.trim() || sendingMessage} className={`p-2 rounded-full ${!newMessage.trim() || sendingMessage ? 'bg-blue-300 dark:bg-blue-800 cursor-not-allowed' : 'bg-blue-500 hover:bg-blue-600' } text-white`} > {sendingMessage ? ( <Loader2 className="h-5 w-5 animate-spin" /> ) : ( <Send size={20} /> )} </button> </form> </div> </> ) : ( <div className="flex flex-col items-center justify-center h-full text-gray-500 dark:text-gray-400"> <p className="mb-2">Select a conversation to start messaging</p> </div> )} </div> </div> {/* Mobile view for active conversation */} {activeConversation && ( <div className={`fixed inset-0 z-50 md:hidden bg-white dark:bg-gray-800 ${activeConversation ? 'flex' : 'hidden' } flex-col`} > {/* Header */} <div className="p-4 border-b border-gray-200 dark:border-gray-700 flex items-center"> <button onClick={() => setActiveConversation(null)} className="mr-3"> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"> <path d="M19 12H5M12 19l-7-7 7-7" /> </svg> </button> <Image src={activeConversation.profileImage || '/default-avatar.png'} alt={activeConversation.username} width={40} height={40} className="rounded-full mr-3" /> <div> <h3 className="font-medium">{activeConversation.username}</h3> <p className="text-sm text-gray-500 dark:text-gray-400">{activeConversation.handle}</p> </div> </div> {/* Messages */} <div className="flex-1 overflow-y-auto p-4 space-y-4"> {messages.map((message) => ( <div key={message.id} className={`flex ${message.senderId === session?.user.id ? 'justify-end' : 'justify-start' }`} > <div className={`max-w-[80%] p-3 rounded-lg ${message.senderId === session?.user.id ? 'bg-blue-500 text-white rounded-br-none' : 'bg-gray-100 dark:bg-gray-700 rounded-bl-none' }`} > <p>{message.content}</p> <div className={`text-xs mt-1 ${message.senderId === session?.user.id ? 'text-blue-100' : 'text-gray-500' }`} > {formatDistanceToNow(new Date(message.createdAt), { addSuffix: true })} </div> </div> </div> ))} <div ref={messagesEndRef} /> </div> {/* Input */} <div className="p-4 border-t border-gray-200 dark:border-gray-700"> <form onSubmit={handleSendMessage} className="flex items-center space-x-2"> <input type="text" placeholder="Type a message..." value={newMessage} onChange={(e) => setNewMessage(e.target.value)} className="flex-1 p-2 border border-gray-300 dark:border-gray-600 rounded-full bg-gray-100 dark:bg-gray-700" disabled={sendingMessage} /> <button type="submit" disabled={!newMessage.trim() || sendingMessage} className={`p-2 rounded-full ${!newMessage.trim() || sendingMessage ? 'bg-blue-300 dark:bg-blue-800 cursor-not-allowed' : 'bg-blue-500 hover:bg-blue-600' } text-white`} > {sendingMessage ? ( <Loader2 className="h-5 w-5 animate-spin" /> ) : ( <Send size={20} /> )} </button> </form> </div> </div> )} </div> ); }
```

# src/app/analytics/page.tsx

```tsx
'use client'; import { useState, useEffect } from 'react'; import { useSession } from 'next-auth/react'; import { LineChart, Line, BarChart, Bar, PieChart, Pie, AreaChart, Area, XAxis, YAxis, CartesianGrid, Tooltip, Legend, ResponsiveContainer, Cell } from 'recharts'; import { Loader2 } from 'lucide-react'; // Types for our analytics data interface EngagementData { date: string; likes: number; comments: number; shares: number; } interface ImpressionData { date: string; impressions: number; } interface ContentTypeData { type: string; count: number; color: string; } interface FollowerGrowthData { date: string; followers: number; } export default function AnalyticsPage() { const { data: session, status } = useSession(); const [loading, setLoading] = useState(true); const [error, setError] = useState<string | null>(null); const [engagementData, setEngagementData] = useState<EngagementData[]>([]); const [impressionData, setImpressionData] = useState<ImpressionData[]>([]); const [contentTypeData, setContentTypeData] = useState<ContentTypeData[]>([]); const [followerGrowthData, setFollowerGrowthData] = useState<FollowerGrowthData[]>([]); useEffect(() => { if (status === 'authenticated') { fetchAnalyticsData(); } }, [status]); const fetchAnalyticsData = async () => { try { setLoading(true); // In a real app, these would be separate API calls to fetch different metrics // For this example, we'll simulate with dummy data // Fetch engagement data const engagementResponse = await fetch('/api/analytics/engagement'); const engagement = await engagementResponse.json(); setEngagementData(engagement); // Fetch impression data const impressionResponse = await fetch('/api/analytics/impressions'); const impressions = await impressionResponse.json(); setImpressionData(impressions); // Fetch content type data const contentTypeResponse = await fetch('/api/analytics/content-types'); const contentTypes = await contentTypeResponse.json(); setContentTypeData(contentTypes); // Fetch follower growth data const followerResponse = await fetch('/api/analytics/follower-growth'); const followerGrowth = await followerResponse.json(); setFollowerGrowthData(followerGrowth); } catch (err) { setError('Failed to load analytics data'); console.error(err); } finally { setLoading(false); } }; // For demo purposes, generate some sample data if API isn't implemented yet useEffect(() => { if (status === 'authenticated' && loading) { // Sample engagement data for the last 7 days const sampleEngagementData: EngagementData[] = []; const sampleImpressionData: ImpressionData[] = []; const sampleFollowerGrowthData: FollowerGrowthData[] = []; for (let i = 6; i >= 0; i--) { const date = new Date(); date.setDate(date.getDate() - i); const dateStr = date.toLocaleDateString('en-US', { month: 'short', day: 'numeric' }); sampleEngagementData.push({ date: dateStr, likes: Math.floor(Math.random() * 50) + 10, comments: Math.floor(Math.random() * 20) + 5, shares: Math.floor(Math.random() * 10) + 2 }); sampleImpressionData.push({ date: dateStr, impressions: Math.floor(Math.random() * 500) + 100 }); sampleFollowerGrowthData.push({ date: dateStr, followers: 200 + Math.floor(Math.random() * 20) * i }); } const sampleContentTypeData: ContentTypeData[] = [ { type: 'Text Only', count: 45, color: '#8884d8' }, { type: 'With Images', count: 30, color: '#82ca9d' }, { type: 'With Links', count: 15, color: '#ffc658' }, { type: 'With Videos', count: 10, color: '#ff8042' } ]; setEngagementData(sampleEngagementData); setImpressionData(sampleImpressionData); setContentTypeData(sampleContentTypeData); setFollowerGrowthData(sampleFollowerGrowthData); setLoading(false); } }, [status, loading]); if (status === 'loading' || loading) { return ( <div className="flex justify-center items-center h-screen"> <Loader2 className="h-8 w-8 animate-spin text-blue-500" /> </div> ); } if (status === 'unauthenticated') { return ( <div className="max-w-4xl mx-auto p-6 text-center"> <h1 className="text-2xl font-bold mb-4">Sign in to view your analytics</h1> <p>You need to be signed in to access this page.</p> </div> ); } if (error) { return ( <div className="max-w-4xl mx-auto p-6"> <div className="bg-red-100 dark:bg-red-900 p-4 rounded-lg text-red-600 dark:text-red-200"> {error} </div> </div> ); } return ( <div className="max-w-6xl mx-auto p-6"> <h1 className="text-2xl font-bold mb-6">Analytics Dashboard</h1> <div className="grid grid-cols-1 md:grid-cols-2 gap-6 mb-6"> {/* Engagement Metrics */} <div className="bg-white dark:bg-gray-800 p-4 rounded-lg shadow"> <h2 className="text-lg font-semibold mb-4">Post Engagement</h2> <div className="h-64"> <ResponsiveContainer width="100%" height="100%"> <BarChart data={engagementData}> <CartesianGrid strokeDasharray="3 3" /> <XAxis dataKey="date" /> <YAxis /> <Tooltip /> <Legend /> <Bar dataKey="likes" name="Likes" fill="#8884d8" /> <Bar dataKey="comments" name="Comments" fill="#82ca9d" /> <Bar dataKey="shares" name="Shares" fill="#ffc658" /> </BarChart> </ResponsiveContainer> </div> </div> {/* Impressions */} <div className="bg-white dark:bg-gray-800 p-4 rounded-lg shadow"> <h2 className="text-lg font-semibold mb-4">Post Impressions</h2> <div className="h-64"> <ResponsiveContainer width="100%" height="100%"> <AreaChart data={impressionData}> <CartesianGrid strokeDasharray="3 3" /> <XAxis dataKey="date" /> <YAxis /> <Tooltip /> <Area type="monotone" dataKey="impressions" name="Impressions" stroke="#8884d8" fill="#8884d8" fillOpacity={0.3} /> </AreaChart> </ResponsiveContainer> </div> </div> {/* Content Type Distribution */} <div className="bg-white dark:bg-gray-800 p-4 rounded-lg shadow"> <h2 className="text-lg font-semibold mb-4">Content Type Distribution</h2> <div className="h-64"> <ResponsiveContainer width="100%" height="100%"> <PieChart> <Pie data={contentTypeData} dataKey="count" nameKey="type" cx="50%" cy="50%" outerRadius={80} label > {contentTypeData.map((entry, index) => ( <Cell key={`cell-${index}`} fill={entry.color} /> ))} </Pie> <Tooltip /> <Legend /> </PieChart> </ResponsiveContainer> </div> </div> {/* Follower Growth */} <div className="bg-white dark:bg-gray-800 p-4 rounded-lg shadow"> <h2 className="text-lg font-semibold mb-4">Follower Growth</h2> <div className="h-64"> <ResponsiveContainer width="100%" height="100%"> <LineChart data={followerGrowthData}> <CartesianGrid strokeDasharray="3 3" /> <XAxis dataKey="date" /> <YAxis /> <Tooltip /> <Line type="monotone" dataKey="followers" name="Followers" stroke="#82ca9d" strokeWidth={2} /> </LineChart> </ResponsiveContainer> </div> </div> </div> {/* Summary Stats */} <div className="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-4 gap-4 mb-6"> <div className="bg-white dark:bg-gray-800 p-4 rounded-lg shadow text-center"> <p className="text-gray-500 dark:text-gray-400 mb-1">Total Posts</p> <h3 className="text-2xl font-bold">128</h3> </div> <div className="bg-white dark:bg-gray-800 p-4 rounded-lg shadow text-center"> <p className="text-gray-500 dark:text-gray-400 mb-1">Total Followers</p> <h3 className="text-2xl font-bold">{followerGrowthData[followerGrowthData.length - 1]?.followers || 0}</h3> </div> <div className="bg-white dark:bg-gray-800 p-4 rounded-lg shadow text-center"> <p className="text-gray-500 dark:text-gray-400 mb-1">Avg. Engagement Rate</p> <h3 className="text-2xl font-bold">5.2%</h3> </div> <div className="bg-white dark:bg-gray-800 p-4 rounded-lg shadow text-center"> <p className="text-gray-500 dark:text-gray-400 mb-1">Top Performing Post</p> <h3 className="text-2xl font-bold">342 likes</h3> </div> </div> {/* Recommendations */} <div className="bg-white dark:bg-gray-800 p-4 rounded-lg shadow mb-6"> <h2 className="text-lg font-semibold mb-4">Recommendations</h2> <ul className="space-y-2"> <li className="flex items-start"> <span className="inline-block w-2 h-2 rounded-full bg-blue-500 mt-2 mr-2"></span> <p>Post more content with images to increase engagement based on your audience preferences.</p> </li> <li className="flex items-start"> <span className="inline-block w-2 h-2 rounded-full bg-blue-500 mt-2 mr-2"></span> <p>Optimal posting time for your audience appears to be between 6-8 PM.</p> </li> <li className="flex items-start"> <span className="inline-block w-2 h-2 rounded-full bg-blue-500 mt-2 mr-2"></span> <p>Your follower growth is steady. Consider engaging more with trending topics to accelerate growth.</p> </li> </ul> </div> </div> ); }
```

# src/components/user/FollowStats.tsx

```tsx
import { useState, useEffect } from 'react'; import Link from 'next/link'; import { Loader2 } from 'lucide-react'; import { useParams } from 'next/navigation'; interface FollowStatsProps { userId: string; className?: string; showLinks?: boolean; } export default function FollowStats({ userId, className = '', showLinks = true }: FollowStatsProps) { const { handle } = useParams(); const [counts, setCounts] = useState<{ followers: number; following: number } | null>(null); const [loading, setLoading] = useState(true); const [error, setError] = useState<string | null>(null); useEffect(() => { const fetchCounts = async () => { if (!userId) return; try { setLoading(true); setError(null); const response = await fetch(`/api/users/${userId}/follow-counts`); if (!response.ok) { throw new Error('Failed to fetch follow counts'); } const data = await response.json(); setCounts(data); } catch (err) { console.error('Error fetching follow counts:', err); setError('Failed to load follow counts'); } finally { setLoading(false); } }; fetchCounts(); }, [userId]); if (loading) { return ( <div className={`flex justify-center items-center py-2 ${className}`}> <Loader2 className="h-4 w-4 animate-spin text-gray-400" /> </div> ); } if (error || !counts) { return ( <div className={`text-sm text-gray-500 dark:text-gray-400 ${className}`}> Unable to load follow stats </div> ); } const StatItem = ({ label, count, href }: { label: string; count: number; href: string }) => { if (showLinks) { return ( <Link href={href} className="hover:underline flex items-center space-x-1" > <span className="font-bold">{count}</span> <span className="text-gray-600 dark:text-gray-400">{label}</span> </Link> ); } return ( <div className="flex items-center space-x-1"> <span className="font-bold">{count}</span> <span className="text-gray-600 dark:text-gray-400">{label}</span> </div> ); }; return ( <div className={`flex space-x-4 ${className}`}> <StatItem label="Followers" count={counts.followers} href={`/profile/${handle}/followers`} /> <StatItem label="Following" count={counts.following} href={`/profile/${handle}/following`} /> </div> ); }
```

# src/components/user/FollowButton.tsx

```tsx
import React from 'react'; import { useSession } from 'next-auth/react'; import { UserPlus, UserCheck, Loader2 } from 'lucide-react'; import useFollowUser from '@/hooks/useFollowUser'; interface FollowButtonProps { userId: string; initialFollowing?: boolean; onFollowChange?: (isFollowing: boolean) => void; variant?: 'default' | 'outline' | 'small'; className?: string; } export default function FollowButton({ userId, initialFollowing = false, onFollowChange, variant = 'default', className = '', }: FollowButtonProps) { const { data: session, status } = useSession(); const { isFollowing, isLoading, error, toggleFollow } = useFollowUser(userId, initialFollowing); // Callback when follow state changes React.useEffect(() => { if (onFollowChange) { onFollowChange(isFollowing); } }, [isFollowing, onFollowChange]); // Handle errors React.useEffect(() => { if (error) { console.error('Follow error:', error); // You could show a toast notification here } }, [error]); // Don't render if not authenticated or is the current user if (status === 'loading' || !session || session.user.id === userId) { return null; } // Style based on variant let buttonStyle = ''; if (variant === 'default') { buttonStyle = isFollowing ? 'bg-gray-200 text-gray-800 hover:bg-red-100 hover:text-red-600 dark:bg-gray-700 dark:text-gray-200 dark:hover:bg-red-900 dark:hover:text-red-300' : 'bg-blue-500 text-white hover:bg-blue-600 dark:bg-blue-600 dark:hover:bg-blue-700'; } else if (variant === 'outline') { buttonStyle = isFollowing ? 'border border-gray-300 text-gray-700 hover:border-red-300 hover:text-red-600 dark:border-gray-600 dark:text-gray-300 dark:hover:border-red-700 dark:hover:text-red-400' : 'border border-blue-500 text-blue-500 hover:bg-blue-50 dark:border-blue-400 dark:text-blue-400 dark:hover:bg-blue-900/20'; } else if (variant === 'small') { buttonStyle = isFollowing ? 'text-gray-600 hover:text-red-600 dark:text-gray-400 dark:hover:text-red-400' : 'text-blue-500 hover:text-blue-600 dark:text-blue-400 dark:hover:text-blue-300'; } const sizeClass = variant === 'small' ? 'py-1 px-2 text-sm' : 'py-2 px-4'; return ( <button onClick={toggleFollow} disabled={isLoading} className={`flex items-center justify-center font-medium rounded-full transition-colors ${sizeClass} ${buttonStyle} ${className} ${isLoading ? 'opacity-70 cursor-not-allowed' : '' }`} aria-label={isFollowing ? 'Unfollow' : 'Follow'} > {isLoading ? ( <Loader2 className="h-4 w-4 animate-spin" /> ) : isFollowing ? ( <> <UserCheck className="h-4 w-4 mr-1" /> {variant !== 'small' && 'Following'} </> ) : ( <> <UserPlus className="h-4 w-4 mr-1" /> {variant !== 'small' && 'Follow'} </> )} </button> ); }
```

# src/components/ui/Modal.tsx

```tsx
// src/components/ui/Modal.tsx 'use client'; import React, { ReactNode, useEffect } from 'react'; interface ModalProps { isOpen: boolean; onClose: () => void; title?: string; children: ReactNode; } export default function Modal({ isOpen, onClose, title, children }: ModalProps) { useEffect(() => { const handleKey = (e: KeyboardEvent) => { if (e.key === 'Escape') onClose(); }; document.addEventListener('keydown', handleKey); return () => document.removeEventListener('keydown', handleKey); }, [onClose]); if (!isOpen) return null; return ( <div className="fixed inset-0 z-50 flex items-center justify-center bg-black bg-opacity-50"> <div className="bg-white dark:bg-gray-800 rounded-lg shadow-lg w-full max-w-lg mx-4 overflow-hidden"> <div className="flex justify-between items-center px-4 py-2 border-b border-gray-200 dark:border-gray-700"> {title && <h3 className="text-lg font-medium text-gray-900 dark:text-gray-100">{title}</h3>} <button onClick={onClose} className="text-gray-500 hover:text-gray-700 dark:text-gray-400 dark:hover:text-gray-200" aria-label="Close" > × </button> </div> <div className="p-4">{children}</div> </div> </div> ); }
```

# src/components/ui/Input.tsx

```tsx
// src/components/ui/Input.tsx 'use client'; import React from 'react'; type InputProps = React.InputHTMLAttributes<HTMLInputElement>; export default function Input({ className = '', ...props }: InputProps) { return ( <input {...props} className={`w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 dark:border-gray-600 dark:bg-gray-700 dark:text-gray-200 ${className}`} /> ); }
```

# src/components/ui/Button.tsx

```tsx
// src/components/ui/Button.tsx 'use client'; import React from 'react'; interface ButtonProps extends React.ButtonHTMLAttributes<HTMLButtonElement> { variant?: 'primary' | 'secondary' | 'outline'; children: React.ReactNode; } export default function Button({ variant = 'primary', className = '', children, ...props }: ButtonProps) { const base = 'px-4 py-2 rounded-full font-medium transition-colors focus:outline-none focus:ring-2 focus:ring-offset-2'; let style = ''; switch (variant) { case 'secondary': style = 'bg-gray-200 text-gray-800 hover:bg-gray-300 focus:ring-gray-300 dark:bg-gray-700 dark:text-gray-200 dark:hover:bg-gray-600 dark:focus:ring-gray-500'; break; case 'outline': style = 'border border-gray-300 text-gray-800 hover:bg-gray-100 focus:ring-gray-300 dark:border-gray-600 dark:text-gray-200 dark:hover:bg-gray-700 dark:focus:ring-gray-500'; break; case 'primary': default: style = 'bg-blue-500 text-white hover:bg-blue-600 focus:ring-blue-500'; } return ( <button className={`${base} ${style} ${className}`} {...props}> {children} </button> ); }
```

# src/components/providers/ThemeSync.tsx

```tsx
// src/components/providers/ThemeSync.tsx 'use client'; import { useUI } from '@/context/ui-context'; import { useEffect } from 'react'; export default function ThemeSync() { const { darkMode } = useUI(); useEffect(() => { // Toggle the `dark` class on <html> on every change if (darkMode) { document.documentElement.classList.add('dark'); } else { document.documentElement.classList.remove('dark'); } }, [darkMode]); return null; // no visual output }
```

# src/components/providers/AuthProvider.tsx

```tsx
// src/components/providers/AuthProvider.tsx 'use client'; import { SessionProvider, SessionProviderProps } from 'next-auth/react'; import { ReactNode } from 'react'; interface AuthProviderProps extends Pick<SessionProviderProps, 'session'> { children: ReactNode; } export default function AuthProvider({ session, children }: AuthProviderProps) { return <SessionProvider session={session}>{children}</SessionProvider>; }
```

# src/components/layout/Sidebar.tsx

```tsx
// src/components/layout/Sidebar.tsx 'use client'; import { useSession, signIn, signOut } from 'next-auth/react'; import Link from 'next/link'; import Image from 'next/image'; import { useUI } from '@/context/ui-context'; import { useState, useEffect, useCallback } from 'react'; import { usePathname } from 'next/navigation'; import { Home, Search, Bell, MessageSquare, User, BarChart2, Users, Settings, Moon, Sun, Menu, X, LogIn, LogOut, } from 'lucide-react'; export default function Sidebar() { const { data: session, status } = useSession(); const ui = useUI(); const { sidebarOpen, toggleSidebar, darkMode, toggleDarkMode } = ui; const pathname = usePathname(); const [followerCount, setFollowerCount] = useState(0); const [followingCount, setFollowingCount] = useState(0); // Debug logs console.debug('[Sidebar] status:', status); console.debug('[Sidebar] session.user:', session?.user); console.debug('[Sidebar] UI context:', ui); const fetchFollowCounts = useCallback(async () => { if (!session?.user?.id) return; try { console.debug('[Sidebar] fetching follow counts for', session.user.id); const response = await fetch( `/api/users/${session.user.id}/follow-counts` ); if (response.ok) { const data = await response.json(); console.debug('[Sidebar] follow counts response:', data); setFollowerCount(data.followers); setFollowingCount(data.following); } } catch (error) { console.error('[Sidebar] Failed to fetch follow counts:', error); } }, [session?.user?.id]); useEffect(() => { fetchFollowCounts(); }, [fetchFollowCounts]); if (status === 'loading') { console.debug('[Sidebar] rendering loading skeleton'); return ( <aside className="fixed top-0 left-0 z-40 h-screen w-16 bg-white dark:bg-gray-800 border-r border-gray-200 dark:border-gray-700"> <div className="flex justify-center p-4"> <div className="animate-pulse h-8 w-8 bg-gray-200 dark:bg-gray-700 rounded-full" /> </div> </aside> ); } if (!session) { console.debug('[Sidebar] user not signed in'); return ( <aside className="fixed top-0 left-0 z-40 h-screen w-16 bg-white dark:bg-gray-800 border-r border-gray-200 dark:border-gray-700 p-4"> <button onClick={() => { console.debug('[Sidebar] signIn() called'); signIn(); }} className="flex flex-col items-center space-y-1" > <LogIn size={24} className="text-gray-500 dark:text-gray-400" /> <span className="text-xs text-gray-600 dark:text-gray-300">Sign In</span> </button> </aside> ); } const displayName = session.user.username; const displayHandle = session.user.handle; console.debug('[Sidebar] rendering signed-in sidebar for handle:', displayHandle); return ( <> <aside className={`fixed top-0 left-0 z-40 h-screen bg-white dark:bg-gray-800 border-r border-gray-200 dark:border-gray-700 flex flex-col transition-width duration-200 overflow-hidden ${sidebarOpen ? 'w-64' : 'w-16' }`} > {/* Header */} <div className="flex items-center justify-between p-4"> {sidebarOpen && ( <Link href="/" className="text-xl font-bold text-blue-500"> SocialApp </Link> )} <button onClick={() => { console.debug('[Sidebar] toggleSidebar() called, now open:', !sidebarOpen); toggleSidebar(); }} className="p-2 rounded-full hover:bg-gray-100 dark:hover:bg-gray-700" > {sidebarOpen ? <X size={20} /> : <Menu size={20} />} </button> </div> {/* Profile Section */} {sidebarOpen && ( <div className="mb-6 px-4"> <div className="flex items-center space-x-3 mb-4"> <Image src={session.user.image ?? '/default-avatar.png'} alt={displayName} width={48} height={48} className="rounded-full" /> <div> <h3 className="font-medium text-gray-900 dark:text-gray-100"> {displayName} </h3> <p className="text-sm text-gray-500 dark:text-gray-400"> @{displayHandle} </p> </div> </div> <div className="flex justify-between text-sm"> <Link href={`/profile/${displayHandle}/followers`} className="hover:underline" onClick={() => console.debug('[Sidebar] navigate to followers of', displayHandle) } > <span className="font-bold">{followerCount}</span> Followers </Link> <Link href={`/profile/${displayHandle}/following`} className="hover:underline" onClick={() => console.debug('[Sidebar] navigate to following of', displayHandle) } > <span className="font-bold">{followingCount}</span> Following </Link> </div> </div> )} {/* Navigation */} <nav className="flex-1 px-2 space-y-1"> {[ { label: 'Home', icon: Home, href: '/' }, { label: 'Search', icon: Search, href: '/search' }, { label: 'Notifications', icon: Bell, href: '/notifications' }, { label: 'Messages', icon: MessageSquare, href: '/messages' }, { label: 'Profile', icon: User, href: `/profile/${displayHandle}` }, { label: 'Analytics', icon: BarChart2, href: '/analytics' }, { label: 'Communities', icon: Users, href: '/communities' }, ].map(({ label, icon: Icon, href }) => ( <Link key={label} href={href} onClick={() => console.debug('[Sidebar] nav click:', label, href)} className={`flex items-center p-2 rounded-lg hover:bg-gray-100 dark:hover:bg-gray-700 transition-colors ${pathname === href || pathname.startsWith(href + '/') ? 'bg-gray-100 dark:bg-gray-700' : '' }`} > <Icon size={20} /> {sidebarOpen && <span className="ml-3">{label}</span>} </Link> ))} </nav> {/* Bottom Controls */} <div className="mt-auto px-2 pb-4 space-y-1"> <Link href="/settings" className={`flex items-center p-2 rounded-lg hover:bg-gray-100 dark:hover:bg-gray-700 transition-colors ${pathname.startsWith('/settings') ? 'bg-gray-100 dark:bg-gray-700' : '' }`} onClick={() => console.debug('[Sidebar] navigate to settings')} > <Settings size={20} /> {sidebarOpen && <span className="ml-3">Settings</span>} </Link> <button onClick={() => { console.debug('[Sidebar] toggleDarkMode() called, now dark:', !darkMode); toggleDarkMode(); }} className="flex items-center p-2 rounded-lg w-full hover:bg-gray-100 dark:hover:bg-gray-700 transition-colors" > {darkMode ? <Sun size={20} /> : <Moon size={20} />} {sidebarOpen && ( <span className="ml-3">{darkMode ? 'Light Mode' : 'Dark Mode'}</span> )} </button> <button onClick={() => { console.debug('[Sidebar] signOut() called'); signOut({ callbackUrl: '/auth/signin' }); }} className="flex items-center p-2 rounded-lg w-full hover:bg-gray-100 dark:hover:bg-gray-700 transition-colors" > <LogOut size={20} /> {sidebarOpen && <span className="ml-3">Logout</span>} </button> </div> </aside> {/* Mobile overlay */} {sidebarOpen && ( <div className="md:hidden fixed inset-0 z-30 bg-black bg-opacity-50" onClick={() => { console.debug('[Sidebar] overlay click, toggling sidebar'); toggleSidebar(); }} /> )} </> ); }
```

# src/components/layout/MobileFooter.tsx

```tsx
'use client'; import Link from 'next/link'; import { usePathname } from 'next/navigation'; import { useUI } from '@/context/ui-context'; import { Home, Search, Bell, MessageSquare } from 'lucide-react'; import { useSession } from 'next-auth/react'; export default function MobileFooter() { const { sidebarOpen } = useUI(); const pathname = usePathname(); const { data: session } = useSession(); if (!session || sidebarOpen) { return null; // Don't show footer if not logged in or sidebar is open } return ( <nav className="fixed bottom-0 left-0 z-50 w-full h-16 bg-white border-t border-gray-200 dark:bg-gray-800 dark:border-gray-700 md:hidden"> <div className="grid h-full grid-cols-4"> <Link href="/" className="flex flex-col items-center justify-center" > <Home size={24} className={pathname === '/' ? 'text-blue-500' : 'text-gray-500 dark:text-gray-400'} /> <span className="text-xs mt-1">Home</span> </Link> <Link href="/search" className="flex flex-col items-center justify-center" > <Search size={24} className={pathname === '/search' ? 'text-blue-500' : 'text-gray-500 dark:text-gray-400'} /> <span className="text-xs mt-1">Search</span> </Link> <Link href="/notifications" className="flex flex-col items-center justify-center" > <Bell size={24} className={pathname === '/notifications' ? 'text-blue-500' : 'text-gray-500 dark:text-gray-400'} /> <span className="text-xs mt-1">Notifications</span> </Link> <Link href="/messages" className="flex flex-col items-center justify-center" > <MessageSquare size={24} className={pathname === '/messages' ? 'text-blue-500' : 'text-gray-500 dark:text-gray-400'} /> <span className="text-xs mt-1">Messages</span> </Link> </div> </nav> ); }
```

# src/components/layout/ClientLayout.tsx

```tsx
// src/components/layout/ClientLayout.tsx 'use client'; import { ReactNode } from 'react'; import Sidebar from '@/components/layout/Sidebar'; import MobileFooter from '@/components/layout/MobileFooter'; import ThemeSync from '@/components/providers/ThemeSync'; interface ClientLayoutProps { children: ReactNode; } export default function ClientLayout({ children }: ClientLayoutProps) { return ( <> {/* Keep the HTML class in sync */} <ThemeSync /> <div className="flex min-h-screen bg-gray-50 dark:bg-gray-900"> <Sidebar /> <main className="flex-1 p-4">{children}</main> <MobileFooter /> </div> </> ); }
```

# src/components/post/PostCard.tsx

```tsx
import { useState } from 'react'; import Image from 'next/image'; import Link from 'next/link'; import { formatDistanceToNow } from 'date-fns'; import { useSession } from 'next-auth/react'; import { MessageSquare, Repeat, Heart, ChartBar, Bookmark, Share2 } from 'lucide-react'; import { Post } from '@/lib/validations'; interface PostCardProps { post: Post & { author: { username: string; handle: string; profileImage: string | null; }; _count: { comments: number; likes: number; }; liked?: boolean; bookmarked?: boolean; }; } export default function PostCard({ post }: PostCardProps) { const { data: session } = useSession(); const [liked, setLiked] = useState(post.liked || false); const [likeCount, setLikeCount] = useState(post._count.comments || 0); const [bookmarked, setBookmarked] = useState(post.bookmarked || false); const [imageError, setImageError] = useState<Record<string, boolean>>({}); const handleLike = async () => { if (!session) return; try { const response = await fetch(`/api/posts/${post.id}/like`, { method: liked ? 'DELETE' : 'POST', headers: { 'Content-Type': 'application/json' }, }); if (response.ok) { setLiked(!liked); setLikeCount(prev => liked ? prev - 1 : prev + 1); } } catch (error) { console.error('Error toggling like:', error); } }; const handleBookmark = async () => { if (!session) return; try { const response = await fetch(`/api/posts/${post.id}/bookmark`, { method: bookmarked ? 'DELETE' : 'POST', headers: { 'Content-Type': 'application/json' }, }); if (response.ok) { setBookmarked(!bookmarked); } } catch (error) { console.error('Error toggling bookmark:', error); } }; // Parse image URLs from JSON string const images = post.images ? JSON.parse(post.images) : []; return ( <article className="bg-white dark:bg-gray-800 border-b border-gray-200 dark:border-gray-700 p-4"> {/* Post header */} <div className="flex items-start mb-3"> <Link href={`/profile/${post.author.handle}`} className="flex-shrink-0"> <Image src={post.author.profileImage || '/default-avatar.png'} alt={post.author.username} width={48} height={48} className="rounded-full" /> </Link> <div className="ml-3 flex-1"> <div className="flex items-center"> <Link href={`/profile/${post.author.handle}`} className="font-bold hover:underline"> {post.author.username} </Link> <Link href={`/profile/${post.author.handle}`} className="ml-2 text-gray-500 dark:text-gray-400 hover:underline"> {post.author.handle} </Link> <span className="mx-1 text-gray-500 dark:text-gray-400">·</span> <span className="text-gray-500 dark:text-gray-400"> {formatDistanceToNow(new Date(post.createdAt), { addSuffix: true })} </span> </div> {/* Post content */} <p className="mt-2 whitespace-pre-wrap break-words">{post.text}</p> {/* Post images */} {images.length > 0 && ( <div className={`mt-3 grid gap-2 ${images.length > 1 ? 'grid-cols-2' : 'grid-cols-1'}`}> {images.map((imageUrl: string, index: number) => ( <div key={index} className="relative overflow-hidden rounded-lg"> {!imageError[index] ? ( <Image src={imageUrl} alt="Post image" width={500} height={imageUrl === images[0] ? 500 : 250} layout="responsive" className="object-cover" onError={() => setImageError(prev => ({ ...prev, [index]: true }))} /> ) : ( <div className="bg-gray-200 dark:bg-gray-700 w-full h-full flex items-center justify-center"> <span className="text-gray-500 dark:text-gray-400">Image unavailable</span> </div> )} </div> ))} </div> )} </div> </div> {/* Post footer / actions */} <div className="flex justify-between mt-3"> <button className="flex items-center text-gray-500 dark:text-gray-400 hover:text-blue-500"> <MessageSquare size={18} /> <span className="ml-2">{post._count.comments || 0}</span> </button> <button className="flex items-center text-gray-500 dark:text-gray-400 hover:text-green-500"> <Repeat size={18} /> <span className="ml-2">0</span> </button> <button onClick={handleLike} className={`flex items-center ${liked ? 'text-red-500' : 'text-gray-500 dark:text-gray-400 hover:text-red-500' }`} > <Heart size={18} fill={liked ? 'currentColor' : 'none'} /> <span className="ml-2">{likeCount}</span> </button> <button className="flex items-center text-gray-500 dark:text-gray-400 hover:text-blue-500"> <ChartBar size={18} /> <span className="ml-2">{post.impressions}</span> </button> <div className="flex items-center"> <button onClick={handleBookmark} className={`mr-2 ${bookmarked ? 'text-blue-500' : 'text-gray-500 dark:text-gray-400 hover:text-blue-500' }`} > <Bookmark size={18} fill={bookmarked ? 'currentColor' : 'none'} /> </button> <button className="text-gray-500 dark:text-gray-400 hover:text-blue-500"> <Share2 size={18} /> </button> </div> </div> </article> ); }
```

# src/components/post/FloatingActionButton.tsx

```tsx
'use client'; import { useState } from 'react'; import { PlusIcon } from 'lucide-react'; import CreatePostModal from './CreatePostModal'; export default function FloatingActionButton() { const [isOpen, setIsOpen] = useState(false); return ( <> <button onClick={() => setIsOpen(true)} className="fixed bottom-20 right-4 md:bottom-8 md:right-8 w-14 h-14 rounded-full bg-blue-500 text-white flex items-center justify-center shadow-lg hover:bg-blue-600 transition-colors focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2" aria-label="Create new post" > <PlusIcon className="h-6 w-6" /> </button> {isOpen && <CreatePostModal onClose={() => setIsOpen(false)} />} </> ); }
```

# src/components/post/CreatePostModal.tsx

```tsx
import { useState, useRef, useEffect } from 'react'; import { useSession } from 'next-auth/react'; import Image from 'next/image'; import { X, ImageIcon, Smile, MapPin, Calendar, BarChart2, Loader2 } from 'lucide-react'; import { useFeed } from '@/context/feed-context'; import { postCreateSchema } from '@/lib/validations'; interface CreatePostModalProps { onClose: () => void; } export default function CreatePostModal({ onClose }: CreatePostModalProps) { const { data: session } = useSession(); const { refreshFeed } = useFeed(); const [text, setText] = useState(''); const [images, setImages] = useState<File[]>([]); const [imageUrls, setImageUrls] = useState<string[]>([]); const [loading, setLoading] = useState(false); const [characterCount, setCharacterCount] = useState(0); const [error, setError] = useState<string | null>(null); const maxCharCount = 300; const modalRef = useRef<HTMLDivElement>(null); const textareaRef = useRef<HTMLTextAreaElement>(null); // Focus textarea on open useEffect(() => { if (textareaRef.current) { textareaRef.current.focus(); } }, []); // Close modal on click outside useEffect(() => { const handleClickOutside = (event: MouseEvent) => { if (modalRef.current && !modalRef.current.contains(event.target as Node)) { onClose(); } }; document.addEventListener('mousedown', handleClickOutside); return () => { document.removeEventListener('mousedown', handleClickOutside); }; }, [onClose]); // Escape key closes modal useEffect(() => { const handleEscapeKey = (event: KeyboardEvent) => { if (event.key === 'Escape') { onClose(); } }; document.addEventListener('keydown', handleEscapeKey); return () => { document.removeEventListener('keydown', handleEscapeKey); }; }, [onClose]); const handleTextChange = (e: React.ChangeEvent<HTMLTextAreaElement>) => { const newText = e.target.value; setText(newText); setCharacterCount(newText.length); }; const handleImageUpload = (e: React.ChangeEvent<HTMLInputElement>) => { if (e.target.files && e.target.files.length > 0) { const newFiles = Array.from(e.target.files); const totalImages = [...images, ...newFiles]; // Limit to 4 images if (totalImages.length > 4) { setError('You can only upload up to 4 images'); return; } setImages(totalImages); // Create object URLs for preview const newImageUrls = newFiles.map(file => URL.createObjectURL(file)); setImageUrls([...imageUrls, ...newImageUrls]); } }; const removeImage = (index: number) => { const newImages = [...images]; const newImageUrls = [...imageUrls]; // Revoke object URL to avoid memory leaks URL.revokeObjectURL(newImageUrls[index]); newImages.splice(index, 1); newImageUrls.splice(index, 1); setImages(newImages); setImageUrls(newImageUrls); }; const handleSubmit = async () => { if (!session?.user) return; // Validate text length if (text.trim().length === 0) { setError('Post cannot be empty'); return; } if (text.length > maxCharCount) { setError(`Post exceeds maximum character limit of ${maxCharCount}`); return; } try { setLoading(true); setError(null); // Upload images if any let uploadedImageUrls: string[] = []; if (images.length > 0) { const formData = new FormData(); images.forEach(image => { formData.append('images', image); }); const uploadResponse = await fetch('/api/upload', { method: 'POST', body: formData, }); if (!uploadResponse.ok) { throw new Error('Failed to upload images'); } const uploadResult = await uploadResponse.json(); uploadedImageUrls = uploadResult.urls; } // Create the post const postData = { text, images: uploadedImageUrls.length > 0 ? JSON.stringify(uploadedImageUrls) : undefined, authorId: session.user.id, }; // Validate with Zod const result = postCreateSchema.safeParse(postData); if (!result.success) { setError(result.error.errors[0]?.message || 'Invalid post data'); return; } const response = await fetch('/api/posts', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(postData), }); if (!response.ok) { throw new Error('Failed to create post'); } // Refresh the feed to show the new post refreshFeed(); onClose(); } catch (err) { setError(err instanceof Error ? err.message : 'An unexpected error occurred'); } finally { setLoading(false); } }; // Clean up object URLs when component unmounts useEffect(() => { return () => { imageUrls.forEach(url => URL.revokeObjectURL(url)); }; }, [imageUrls]); return ( <div className="fixed inset-0 z-50 flex items-center justify-center bg-black bg-opacity-50"> <div ref={modalRef} className="bg-white dark:bg-gray-800 rounded-xl shadow-lg w-full max-w-lg mx-4 max-h-[90vh] overflow-hidden flex flex-col" > <div className="p-4 border-b border-gray-200 dark:border-gray-700 flex justify-between items-center"> <h2 className="text-xl font-bold">Create Post</h2> <button onClick={onClose} className="text-gray-500 hover:text-gray-700 dark:text-gray-400 dark:hover:text-gray-200" > <X size={20} /> </button> </div> <div className="p-4 flex-1 overflow-y-auto"> {error && ( <div className="mb-4 p-3 bg-red-100 dark:bg-red-900 text-red-700 dark:text-red-200 rounded-lg"> {error} </div> )} <div className="flex space-x-3"> {session?.user?.image && ( <Image src={session.user.image} alt={session.user.username || 'User'} width={48} height={48} className="rounded-full" /> )} <div className="flex-1"> <textarea ref={textareaRef} value={text} onChange={handleTextChange} placeholder="What's happening?" className="w-full min-h-[100px] bg-transparent border-none focus:ring-0 resize-none" maxLength={maxCharCount} /> {/* Image previews */} {imageUrls.length > 0 && ( <div className="mt-3 grid grid-cols-2 gap-2"> {imageUrls.map((url, index) => ( <div key={index} className="relative rounded-lg overflow-hidden"> <Image src={url} alt={`Selected image ${index + 1}`} width={200} height={200} className="object-cover" /> <button onClick={() => removeImage(index)} className="absolute top-2 right-2 bg-black bg-opacity-50 rounded-full p-1 text-white" > <X size={16} /> </button> </div> ))} </div> )} </div> </div> </div> <div className="p-4 border-t border-gray-200 dark:border-gray-700"> <div className="flex justify-between items-center mb-3"> <div className="flex space-x-2"> <label htmlFor="image-upload" className="cursor-pointer text-blue-500 hover:text-blue-600"> <ImageIcon size={20} /> <input id="image-upload" type="file" accept="image/*" multiple onChange={handleImageUpload} className="hidden" /> </label> <button className="text-blue-500 hover:text-blue-600"> <Smile size={20} /> </button> <button className="text-blue-500 hover:text-blue-600"> <MapPin size={20} /> </button> </div> <div className="text-xs text-gray-500"> {characterCount}/{maxCharCount} </div> </div> <div className="flex justify-end"> <button onClick={handleSubmit} disabled={loading || text.trim().length === 0 || text.length > maxCharCount} className={` px-4 py-2 rounded-full font-medium ${loading || text.trim().length === 0 || text.length > maxCharCount ? 'bg-blue-300 dark:bg-blue-800 cursor-not-allowed' : 'bg-blue-500 hover:bg-blue-600 text-white'} `} > {loading ? ( <div className="flex items-center"> <Loader2 size={16} className="animate-spin mr-2" /> Posting... </div> ) : ( 'Post' )} </button> </div> </div> </div> </div> ); }
```

# src/components/feed/TabBar.tsx

```tsx
'use client'; import { useState, useEffect } from 'react'; import { useFeed } from '@/context/feed-context'; import { useUI } from '@/context/ui-context'; import Image from 'next/image'; export default function TabBar() { const { activeTab, setActiveTab, userCommunities } = useFeed(); const { tabBarVisible } = useUI(); const [isScrolled, setIsScrolled] = useState(false); // Handle scroll effects useEffect(() => { const handleScroll = () => { setIsScrolled(window.scrollY > 10); }; window.addEventListener('scroll', handleScroll); return () => window.removeEventListener('scroll', handleScroll); }, []); return ( <div className={` sticky z-10 top-0 left-0 w-full bg-white dark:bg-gray-800 transition-all duration-300 border-b border-gray-200 dark:border-gray-700 ${tabBarVisible ? 'translate-y-0' : '-translate-y-full'} ${isScrolled ? 'shadow-sm' : ''} `} > <div className="flex overflow-x-auto hide-scrollbar p-2"> <button onClick={() => setActiveTab('for-you')} className={` px-4 py-2 whitespace-nowrap font-medium rounded-full ${activeTab === 'for-you' ? 'bg-blue-100 dark:bg-blue-900 text-blue-600 dark:text-blue-100' : 'text-gray-600 dark:text-gray-300 hover:bg-gray-100 dark:hover:bg-gray-700'} `} > For You </button> <button onClick={() => setActiveTab('following')} className={` px-4 py-2 ml-2 whitespace-nowrap font-medium rounded-full ${activeTab === 'following' ? 'bg-blue-100 dark:bg-blue-900 text-blue-600 dark:text-blue-100' : 'text-gray-600 dark:text-gray-300 hover:bg-gray-100 dark:hover:bg-gray-700'} `} > Following </button> {/* User communities */} {userCommunities.map(community => ( <button key={community.id} onClick={() => setActiveTab(community.id)} className={` flex items-center px-4 py-2 ml-2 whitespace-nowrap font-medium rounded-full ${activeTab === community.id ? 'bg-blue-100 dark:bg-blue-900 text-blue-600 dark:text-blue-100' : 'text-gray-600 dark:text-gray-300 hover:bg-gray-100 dark:hover:bg-gray-700'} `} > {community.image && ( <Image src={community.image} alt={community.name} width={20} height={20} className="rounded-full mr-2" /> )} {community.name} </button> ))} </div> </div> ); }
```

# src/components/feed/Feed.tsx

```tsx
'use client'; import React, { useEffect, useRef, useState } from 'react'; import { useInView } from 'react-intersection-observer'; import { useFeed } from '@/context/feed-context'; import PostCard from '@/components/post/PostCard'; import AdCard from '@/components/feed/AdCard'; import { Loader2 } from 'lucide-react'; import { Advertisement, Post } from '@/lib/validations'; // Define the complete post type with all properties required by PostCard interface CompletePost extends Post { author: { username: string; handle: string; profileImage: string | null; }; _count: { comments: number; likes: number; }; liked?: boolean; bookmarked?: boolean; } export default function Feed() { const { posts, loading, error, hasMore, loadMorePosts } = useFeed(); const [ads, setAds] = useState<Advertisement[]>([]); const { ref, inView } = useInView(); const initialLoadRef = useRef(true); // Load more posts when the user scrolls to the bottom useEffect(() => { if (inView && hasMore && !loading) { loadMorePosts(); } }, [inView, hasMore, loading, loadMorePosts]); // Fetch advertisements for the feed useEffect(() => { const fetchAds = async () => { try { const response = await fetch('/api/ads'); if (response.ok) { const data = await response.json(); setAds(data); } } catch (error) { console.error('Error fetching ads:', error); } }; fetchAds(); }, []); // Wait for initial load to complete useEffect(() => { if (!loading && initialLoadRef.current) { initialLoadRef.current = false; } }, [loading]); // Function to insert ads at specific positions (max 1 ad per 10 posts) const getContentWithAds = () => { const content: React.ReactNode[] = []; let adIndex = 0; posts.forEach((post, index) => { // Type assertion to ensure post is treated as CompletePost // Since we know the API will return the complete structure const fullPost = post as unknown as CompletePost; // Add post to content content.push( <PostCard key={post.id} post={fullPost} /> ); // Show an ad after every 10 posts if ((index + 1) % 10 === 0 && adIndex < ads.length) { content.push( <AdCard key={`ad-${adIndex}`} ad={ads[adIndex]} /> ); adIndex++; } }); return content; }; if (initialLoadRef.current && loading) { return ( <div className="flex justify-center items-center h-64"> <Loader2 className="h-8 w-8 animate-spin text-blue-500" /> </div> ); } if (error) { return ( <div className="bg-red-100 dark:bg-red-900 p-4 rounded-lg text-red-600 dark:text-red-200"> Error: {error} </div> ); } return ( <div className="divide-y divide-gray-200 dark:divide-gray-700"> {posts.length === 0 && !loading ? ( <div className="p-6 text-center text-gray-500 dark:text-gray-400"> No posts to show. Follow more people or communities to see content here. </div> ) : ( <> {getContentWithAds()} {/* Loading more indicator */} {hasMore && ( <div ref={ref} className="flex justify-center p-4"> {loading && <Loader2 className="h-6 w-6 animate-spin text-blue-500" />} </div> )} {/* End of feed message */} {!hasMore && ( <div className="p-6 text-center text-gray-500 dark:text-gray-400"> You&apos;ve reached the end of your feed. </div> )} </> )} </div> ); }
```

# src/components/feed/AdCard.tsx

```tsx
import Image from 'next/image'; import Link from 'next/link'; import { Advertisement } from '@/lib/validations'; import { Info } from 'lucide-react'; interface AdCardProps { ad: Advertisement; } export default function AdCard({ ad }: AdCardProps) { return ( <div className="bg-white dark:bg-gray-800 border border-gray-200 dark:border-gray-700 rounded-lg p-4 mb-4"> <div className="flex items-center justify-between mb-2"> <span className="text-xs text-gray-500 dark:text-gray-400 flex items-center"> <Info size={12} className="mr-1" /> Sponsored </span> </div> <h3 className="text-lg font-bold mb-2">{ad.title}</h3> <p className="text-gray-700 dark:text-gray-300 mb-3">{ad.content}</p> {ad.imageUrl && ( <div className="relative w-full h-48 mb-3 rounded-lg overflow-hidden"> <Image src={ad.imageUrl} alt={ad.title} fill style={{ objectFit: 'cover' }} /> </div> )} {ad.link && ( <Link href={ad.link} target="_blank" rel="noopener noreferrer" className="inline-block px-4 py-2 bg-blue-500 text-white rounded-full hover:bg-blue-600 transition-colors" > Learn More </Link> )} </div> ); }
```

# src/components/profile/EditProfileModal.tsx

```tsx
import React from 'react'; import { useForm } from 'react-hook-form'; import { zodResolver } from '@hookform/resolvers/zod'; import { userUpdateSchema } from '@/lib/validations'; import { z } from 'zod'; import { useSession } from 'next-auth/react'; import Modal from '@/components/ui/Modal'; import Button from '@/components/ui/Button'; import Input from '@/components/ui/Input'; import { toast } from 'react-hot-toast'; // Derive TS type from Zod schema type FormData = z.infer<typeof userUpdateSchema>; interface EditProfileModalProps { isOpen: boolean; onClose: () => void; user: { id: string; username: string; handle: string; profileImage?: string; bio?: string; }; } export default function EditProfileModal({ isOpen, onClose, user }: EditProfileModalProps) { const { data: session } = useSession(); const { register, handleSubmit, formState: { errors, isSubmitting } } = useForm<FormData>({ resolver: zodResolver(userUpdateSchema), defaultValues: { username: user.username, handle: user.handle, profileImage: user.profileImage || '', bio: user.bio || '' } }); const onSubmit = async (values: FormData) => { if (!session?.user) { toast.error('You must be signed in to update your profile'); return; } try { const resp = await fetch(`/api/users/${user.id}`, { method: 'PUT', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(values) }); if (!resp.ok) { const { message } = await resp.json(); throw new Error(message || 'Failed to update profile'); } toast.success('Profile updated!'); onClose(); // Optionally refresh page or session } catch (err) { console.error('Profile update error:', err); toast.error(err instanceof Error ? err.message : 'Unexpected error'); } }; return ( <Modal isOpen={isOpen} onClose={onClose} title="Edit Profile"> <form onSubmit={handleSubmit(onSubmit)} className="space-y-4"> <div> <label className="block text-sm font-medium mb-1">Display Name</label> <Input {...register('username')} placeholder="Your display name" disabled={isSubmitting} /> {errors.username && <p className="text-red-500 text-sm mt-1">{errors.username.message}</p>} </div> <div> <label className="block text-sm font-medium mb-1">Handle</label> <Input {...register('handle')} placeholder="yourhandle" disabled={isSubmitting} /> {errors.handle && <p className="text-red-500 text-sm mt-1">{errors.handle.message}</p>} </div> <div> <label className="block text-sm font-medium mb-1">Profile Image URL</label> <Input {...register('profileImage')} placeholder="https://..." disabled={isSubmitting} /> {errors.profileImage && <p className="text-red-500 text-sm mt-1">{errors.profileImage.message}</p>} {user.profileImage && ( <img src={user.profileImage} alt="Profile preview" className="w-16 h-16 rounded-full mt-2" /> )} </div> <div> <label className="block text-sm font-medium mb-1">Bio</label> <textarea {...register('bio')} placeholder="Tell us about yourself" rows={3} className="w-full p-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500" disabled={isSubmitting} /> {errors.bio && <p className="text-red-500 text-sm mt-1">{errors.bio.message}</p>} </div> <div className="flex justify-end"> <Button variant="secondary" onClick={onClose} disabled={isSubmitting} className="mr-2"> Cancel </Button> <Button type="submit" disabled={isSubmitting}> {isSubmitting ? 'Saving...' : 'Save Changes'} </Button> </div> </form> </Modal> ); }
```

# src/app/profile/[handle]/page.tsx

```tsx
// src/app/profile/[handle]/page.tsx 'use client'; import { useState, useEffect } from 'react'; import { useParams } from 'next/navigation'; import { useSession } from 'next-auth/react'; import Image from 'next/image'; import Link from 'next/link'; import { formatDistanceToNow } from 'date-fns'; import { Loader2, Calendar } from 'lucide-react'; import FollowButton from '@/components/user/FollowButton'; import FollowStats from '@/components/user/FollowStats'; import EditProfileModal from '@/components/profile/EditProfileModal'; interface User { id: string; username: string; handle: string; profileImage: string | null; bio: string | null; createdAt: string; } interface Post { id: string; text: string; images: string | null; createdAt: string; _count: { comments: number; likes: number }; } export default function ProfilePage() { const { handle } = useParams(); const { data: session } = useSession(); const [user, setUser] = useState<User | null>(null); const [posts, setPosts] = useState<Post[]>([]); const [loading, setLoading] = useState(true); const [error, setError] = useState<string | null>(null); const [isFollowing, setIsFollowing] = useState(false); const [editOpen, setEditOpen] = useState(false); useEffect(() => { async function loadData() { setLoading(true); try { // Fetch user by handle const resUser = await fetch(`/api/users/by-handle/${handle}`); if (!resUser.ok) throw new Error('User not found'); const userData: User = await resUser.json(); setUser(userData); // Fetch posts const resPosts = await fetch(`/api/users/${userData.id}/posts`); if (resPosts.ok) { setPosts(await resPosts.json()); } // Check follow status if (session?.user && session.user.id !== userData.id) { const resFollow = await fetch( `/api/users/${session.user.id}/follows/${userData.id}` ); if (resFollow.ok) { const { following } = await resFollow.json(); setIsFollowing(following); } } } catch (err) { console.error(err); setError((err as Error).message); } finally { setLoading(false); } } loadData(); }, [handle, session]); const handleFollowChange = (following: boolean) => { setIsFollowing(following); }; if (loading) { return ( <div className="flex justify-center items-center h-64"> <Loader2 className="h-8 w-8 animate-spin text-blue-500" /> </div> ); } if (error || !user) { return ( <div className="max-w-2xl mx-auto p-4"> <div className="bg-red-100 dark:bg-red-900 p-4 rounded-lg text-red-600 dark:text-red-200"> {error || 'An error occurred'} </div> </div> ); } return ( <> <EditProfileModal isOpen={editOpen} onClose={() => setEditOpen(false)} user={{ id: user.id, username: user.username, handle: user.handle, profileImage: user.profileImage ?? undefined, bio: user.bio ?? undefined, }} /> <div className="max-w-2xl mx-auto pb-16 md:pb-4"> {/* Cover & Profile Image */} <div className="h-32 bg-blue-100 dark:bg-blue-900 relative mb-16"> <div className="absolute -bottom-12 left-4"> <Image src={user.profileImage || '/default-avatar.png'} alt={user.username} width={96} height={96} className="rounded-full border-4 border-white dark:border-gray-800" /> </div> </div> <div className="px-4"> {/* Profile Actions */} <div className="flex justify-end mb-4"> {session?.user.id === user.id ? ( <button onClick={() => setEditOpen(true)} className="px-4 py-2 border border-gray-300 dark:border-gray-600 rounded-full font-medium hover:bg-gray-100 dark:hover:bg-gray-700" > Edit profile </button> ) : ( <FollowButton userId={user.id} initialFollowing={isFollowing} onFollowChange={handleFollowChange} /> )} </div> {/* User Info */} <div className="mb-6"> <h1 className="text-xl font-bold">{user.username}</h1> <p className="text-gray-600 dark:text-gray-400">@{user.handle}</p> {user.bio && <p className="mt-3">{user.bio}</p>} <div className="flex flex-wrap gap-x-4 gap-y-2 mt-3 text-sm text-gray-600 dark:text-gray-400"> <div className="flex items-center"> <Calendar size={16} className="mr-1" /> <span> Joined{' '} {formatDistanceToNow(new Date(user.createdAt), { addSuffix: true, })} </span> </div> </div> <div className="mt-4"> <FollowStats userId={user.id} /> </div> </div> {/* Posts Tab & List */} <div className="border-b border-gray-200 dark:border-gray-700 mb-4"> <div className="flex"> <button className="px-4 py-2 border-b-2 border-blue-500 font-medium text-blue-500"> Posts </button> <button className="px-4 py-2 text-gray-600 dark:text-gray-400"> Replies </button> <button className="px-4 py-2 text-gray-600 dark:text-gray-400"> Media </button> <button className="px-4 py-2 text-gray-600 dark:text-gray-400"> Likes </button> </div> </div> {posts.length === 0 ? ( <div className="text-center py-8 text-gray-500 dark:text-gray-400"> {user.username} hasn&apos;t posted anything yet. </div> ) : ( posts.map((post) => ( <div key={post.id} className="mb-6"> <Link href={`/posts/${post.id}`}> <a className="block p-4 border border-gray-200 dark:border-gray-700 rounded-lg hover:bg-gray-50 dark:hover:bg-gray-800 transition"> <p className="mb-2">{post.text}</p> {post.images && ( <Image src={JSON.parse(post.images)[0] as string} alt="Post image" width={400} height={250} className="rounded-lg" /> )} <div className="mt-2 text-xs text-gray-500 dark:text-gray-400"> {post._count.comments} comments · {post._count.likes} likes ·{' '} {formatDistanceToNow(new Date(post.createdAt), { addSuffix: true, })} </div> </a> </Link> </div> )) )} </div> </div> </> ); }
```

# src/app/auth/signup/page.tsx

```tsx
'use client'; import { useState } from 'react'; import { signIn } from 'next-auth/react'; import { useRouter } from 'next/navigation'; import Link from 'next/link'; import { Github, Facebook, Mail, Loader2 } from 'lucide-react'; import { useForm } from 'react-hook-form'; import { z } from 'zod'; import { zodResolver } from '@hookform/resolvers/zod'; import { signUpSchema } from '@/lib/validations'; type SignUpForm = z.infer<typeof signUpSchema>; export default function SignUpPage() { const router = useRouter(); const [isLoading, setIsLoading] = useState(false); const [error, setError] = useState<string | null>(null); const { register, handleSubmit, formState: { errors }, } = useForm<SignUpForm>({ resolver: zodResolver(signUpSchema), }); const onSubmit = async (data: SignUpForm) => { try { setIsLoading(true); setError(null); // Create user const response = await fetch('/api/auth/signup', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ email: data.email, username: data.username, handle: data.handle, password: data.password, }), }); if (!response.ok) { const errorData = await response.json(); throw new Error(errorData.message || 'Failed to create account'); } // Sign in the user const signInResult = await signIn('credentials', { redirect: false, emailOrUsername: data.email, password: data.password, }); if (signInResult?.error) { setError('Account created, but failed to sign in automatically'); return; } router.push('/'); router.refresh(); } catch (err) { setError(err instanceof Error ? err.message : 'An error occurred during sign up'); console.error(err); } finally { setIsLoading(false); } }; const handleSocialSignIn = (provider: string) => { signIn(provider, { callbackUrl: '/' }); }; return ( <div className="min-h-screen flex items-center justify-center bg-gray-50 dark:bg-gray-900 px-4"> <div className="max-w-md w-full space-y-8 bg-white dark:bg-gray-800 p-8 rounded-xl shadow-md"> <div className="text-center"> <h1 className="text-3xl font-bold">Sign up</h1> <p className="mt-2 text-gray-600 dark:text-gray-400"> Create your SocialApp account </p> </div> {error && ( <div className="bg-red-100 dark:bg-red-900 text-red-600 dark:text-red-200 p-3 rounded-lg"> {error} </div> )} <form className="mt-8 space-y-6" onSubmit={handleSubmit(onSubmit)}> <div className="space-y-4"> <div> <label htmlFor="email" className="block text-sm font-medium text-gray-700 dark:text-gray-300"> Email </label> <input id="email" type="email" {...register('email')} className="mt-1 block w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-md shadow-sm placeholder-gray-400 focus:outline-none focus:ring-blue-500 focus:border-blue-500 dark:bg-gray-700" placeholder="you@example.com" /> {errors.email && ( <p className="mt-1 text-sm text-red-600">{errors.email.message}</p> )} </div> <div> <label htmlFor="username" className="block text-sm font-medium text-gray-700 dark:text-gray-300"> Username </label> <input id="username" type="text" {...register('username')} className="mt-1 block w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-md shadow-sm placeholder-gray-400 focus:outline-none focus:ring-blue-500 focus:border-blue-500 dark:bg-gray-700" placeholder="johndoe" /> {errors.username && ( <p className="mt-1 text-sm text-red-600">{errors.username.message}</p> )} </div> <div> <label htmlFor="handle" className="block text-sm font-medium text-gray-700 dark:text-gray-300"> Handle </label> <div className="mt-1 flex rounded-md shadow-sm"> <span className="inline-flex items-center px-3 rounded-l-md border border-r-0 border-gray-300 dark:border-gray-600 bg-gray-50 dark:bg-gray-700 text-gray-500 dark:text-gray-400 text-sm"> @ </span> <input id="handle" type="text" {...register('handle')} className="block w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-none rounded-r-md focus:outline-none focus:ring-blue-500 focus:border-blue-500 dark:bg-gray-700" placeholder="johndoe" /> </div> {errors.handle && ( <p className="mt-1 text-sm text-red-600">{errors.handle.message}</p> )} </div> <div> <label htmlFor="password" className="block text-sm font-medium text-gray-700 dark:text-gray-300"> Password </label> <input id="password" type="password" {...register('password')} className="mt-1 block w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-md shadow-sm placeholder-gray-400 focus:outline-none focus:ring-blue-500 focus:border-blue-500 dark:bg-gray-700" placeholder="Create a password (min. 8 characters)" /> {errors.password && ( <p className="mt-1 text-sm text-red-600">{errors.password.message}</p> )} </div> </div> <div> <button type="submit" disabled={isLoading} className="w-full flex justify-center py-2 px-4 border border-transparent rounded-md shadow-sm text-sm font-medium text-white bg-blue-600 hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500 disabled:opacity-75 disabled:cursor-not-allowed" > {isLoading ? ( <Loader2 className="h-5 w-5 animate-spin" /> ) : ( 'Sign up' )} </button> </div> <div className="text-xs text-gray-500 dark:text-gray-400"> By signing up, you agree to our Terms of Service and Privacy Policy. </div> </form> <div className="mt-6"> <div className="relative"> <div className="absolute inset-0 flex items-center"> <div className="w-full border-t border-gray-300 dark:border-gray-600"></div> </div> <div className="relative flex justify-center text-sm"> <span className="px-2 bg-white dark:bg-gray-800 text-gray-500">Or continue with</span> </div> </div> <div className="mt-6 grid grid-cols-3 gap-3"> <button onClick={() => handleSocialSignIn('github')} className="flex justify-center items-center py-2 px-4 border border-gray-300 dark:border-gray-600 rounded-md shadow-sm text-sm font-medium text-gray-700 dark:text-gray-300 bg-white dark:bg-gray-700 hover:bg-gray-50 dark:hover:bg-gray-600" > <Github className="h-5 w-5" /> </button> <button onClick={() => handleSocialSignIn('google')} className="flex justify-center items-center py-2 px-4 border border-gray-300 dark:border-gray-600 rounded-md shadow-sm text-sm font-medium text-gray-700 dark:text-gray-300 bg-white dark:bg-gray-700 hover:bg-gray-50 dark:hover:bg-gray-600" > <svg className="h-5 w-5" viewBox="0 0 24 24"> <g transform="matrix(1, 0, 0, 1, 27.009001, -39.238998)"> <path fill="#4285F4" d="M -3.264 51.509 C -3.264 50.719 -3.334 49.969 -3.454 49.239 L -14.754 49.239 L -14.754 53.749 L -8.284 53.749 C -8.574 55.229 -9.424 56.479 -10.684 57.329 L -10.684 60.329 L -6.824 60.329 C -4.564 58.239 -3.264 55.159 -3.264 51.509 Z" /> <path fill="#34A853" d="M -14.754 63.239 C -11.514 63.239 -8.804 62.159 -6.824 60.329 L -10.684 57.329 C -11.764 58.049 -13.134 58.489 -14.754 58.489 C -17.884 58.489 -20.534 56.379 -21.484 53.529 L -25.464 53.529 L -25.464 56.619 C -23.494 60.539 -19.444 63.239 -14.754 63.239 Z" /> <path fill="#FBBC05" d="M -21.484 53.529 C -21.734 52.809 -21.864 52.039 -21.864 51.239 C -21.864 50.439 -21.724 49.669 -21.484 48.949 L -21.484 45.859 L -25.464 45.859 C -26.284 47.479 -26.754 49.299 -26.754 51.239 C -26.754 53.179 -26.284 54.999 -25.464 56.619 L -21.484 53.529 Z" /> <path fill="#EA4335" d="M -14.754 43.989 C -12.984 43.989 -11.404 44.599 -10.154 45.789 L -6.734 42.369 C -8.804 40.429 -11.514 39.239 -14.754 39.239 C -19.444 39.239 -23.494 41.939 -25.464 45.859 L -21.484 48.949 C -20.534 46.099 -17.884 43.989 -14.754 43.989 Z" /> </g> </svg> </button> <button onClick={() => handleSocialSignIn('facebook')} className="flex justify-center items-center py-2 px-4 border border-gray-300 dark:border-gray-600 rounded-md shadow-sm text-sm font-medium text-gray-700 dark:text-gray-300 bg-white dark:bg-gray-700 hover:bg-gray-50 dark:hover:bg-gray-600" > <Facebook className="h-5 w-5 text-blue-600" /> </button> </div> </div> <div className="text-center mt-6"> <p className="text-sm text-gray-600 dark:text-gray-400"> Already have an account?{' '} <Link href="/auth/signin" className="text-blue-600 hover:text-blue-500"> Sign in </Link> </p> </div> </div> </div> ); }
```

# src/app/auth/signin/page.tsx

```tsx
'use client'; import { useState } from 'react'; import { signIn } from 'next-auth/react'; import { useRouter } from 'next/navigation'; import Link from 'next/link'; import Image from 'next/image'; import { Github, Facebook, Mail, Loader2 } from 'lucide-react'; import { useForm } from 'react-hook-form'; import { z } from 'zod'; import { zodResolver } from '@hookform/resolvers/zod'; const signInSchema = z.object({ emailOrUsername: z.string().min(1, 'Email or username is required'), password: z.string().min(1, 'Password is required'), }); type SignInForm = z.infer<typeof signInSchema>; export default function SignInPage() { const router = useRouter(); const [isLoading, setIsLoading] = useState(false); const [error, setError] = useState<string | null>(null); const { register, handleSubmit, formState: { errors }, } = useForm<SignInForm>({ resolver: zodResolver(signInSchema), }); const onSubmit = async (data: SignInForm) => { try { setIsLoading(true); setError(null); const result = await signIn('credentials', { redirect: false, emailOrUsername: data.emailOrUsername, password: data.password, }); if (result?.error) { setError('Invalid email/username or password'); return; } router.push('/'); router.refresh(); } catch (err) { setError('An error occurred during sign in'); console.error(err); } finally { setIsLoading(false); } }; const handleSocialSignIn = (provider: string) => { signIn(provider, { callbackUrl: '/' }); }; return ( <div className="min-h-screen flex items-center justify-center bg-gray-50 dark:bg-gray-900 px-4"> <div className="max-w-md w-full space-y-8 bg-white dark:bg-gray-800 p-8 rounded-xl shadow-md"> <div className="text-center"> <h1 className="text-3xl font-bold">Sign in</h1> <p className="mt-2 text-gray-600 dark:text-gray-400"> Welcome back to SocialApp </p> </div> {error && ( <div className="bg-red-100 dark:bg-red-900 text-red-600 dark:text-red-200 p-3 rounded-lg"> {error} </div> )} <form className="mt-8 space-y-6" onSubmit={handleSubmit(onSubmit)}> <div className="space-y-4"> <div> <label htmlFor="emailOrUsername" className="block text-sm font-medium text-gray-700 dark:text-gray-300"> Email or Username </label> <input id="emailOrUsername" type="text" {...register('emailOrUsername')} className="mt-1 block w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-md shadow-sm placeholder-gray-400 focus:outline-none focus:ring-blue-500 focus:border-blue-500 dark:bg-gray-700" placeholder="Enter your email or username" /> {errors.emailOrUsername && ( <p className="mt-1 text-sm text-red-600">{errors.emailOrUsername.message}</p> )} </div> <div> <label htmlFor="password" className="block text-sm font-medium text-gray-700 dark:text-gray-300"> Password </label> <input id="password" type="password" {...register('password')} className="mt-1 block w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-md shadow-sm placeholder-gray-400 focus:outline-none focus:ring-blue-500 focus:border-blue-500 dark:bg-gray-700" placeholder="Enter your password" /> {errors.password && ( <p className="mt-1 text-sm text-red-600">{errors.password.message}</p> )} </div> </div> <div className="flex items-center justify-between"> <div className="flex items-center"> <input id="remember-me" name="remember-me" type="checkbox" className="h-4 w-4 text-blue-600 focus:ring-blue-500 border-gray-300 rounded" /> <label htmlFor="remember-me" className="ml-2 block text-sm text-gray-900 dark:text-gray-300"> Remember me </label> </div> <div className="text-sm"> <Link href="/auth/forgot-password" className="text-blue-600 hover:text-blue-500"> Forgot password? </Link> </div> </div> <div> <button type="submit" disabled={isLoading} className="w-full flex justify-center py-2 px-4 border border-transparent rounded-md shadow-sm text-sm font-medium text-white bg-blue-600 hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500 disabled:opacity-75 disabled:cursor-not-allowed" > {isLoading ? ( <Loader2 className="h-5 w-5 animate-spin" /> ) : ( 'Sign in' )} </button> </div> </form> <div className="mt-6"> <div className="relative"> <div className="absolute inset-0 flex items-center"> <div className="w-full border-t border-gray-300 dark:border-gray-600"></div> </div> <div className="relative flex justify-center text-sm"> <span className="px-2 bg-white dark:bg-gray-800 text-gray-500">Or continue with</span> </div> </div> <div className="mt-6 grid grid-cols-3 gap-3"> <button onClick={() => handleSocialSignIn('github')} className="flex justify-center items-center py-2 px-4 border border-gray-300 dark:border-gray-600 rounded-md shadow-sm text-sm font-medium text-gray-700 dark:text-gray-300 bg-white dark:bg-gray-700 hover:bg-gray-50 dark:hover:bg-gray-600" > <Github className="h-5 w-5" /> </button> <button onClick={() => handleSocialSignIn('google')} className="flex justify-center items-center py-2 px-4 border border-gray-300 dark:border-gray-600 rounded-md shadow-sm text-sm font-medium text-gray-700 dark:text-gray-300 bg-white dark:bg-gray-700 hover:bg-gray-50 dark:hover:bg-gray-600" > <svg className="h-5 w-5" viewBox="0 0 24 24"> <g transform="matrix(1, 0, 0, 1, 27.009001, -39.238998)"> <path fill="#4285F4" d="M -3.264 51.509 C -3.264 50.719 -3.334 49.969 -3.454 49.239 L -14.754 49.239 L -14.754 53.749 L -8.284 53.749 C -8.574 55.229 -9.424 56.479 -10.684 57.329 L -10.684 60.329 L -6.824 60.329 C -4.564 58.239 -3.264 55.159 -3.264 51.509 Z" /> <path fill="#34A853" d="M -14.754 63.239 C -11.514 63.239 -8.804 62.159 -6.824 60.329 L -10.684 57.329 C -11.764 58.049 -13.134 58.489 -14.754 58.489 C -17.884 58.489 -20.534 56.379 -21.484 53.529 L -25.464 53.529 L -25.464 56.619 C -23.494 60.539 -19.444 63.239 -14.754 63.239 Z" /> <path fill="#FBBC05" d="M -21.484 53.529 C -21.734 52.809 -21.864 52.039 -21.864 51.239 C -21.864 50.439 -21.724 49.669 -21.484 48.949 L -21.484 45.859 L -25.464 45.859 C -26.284 47.479 -26.754 49.299 -26.754 51.239 C -26.754 53.179 -26.284 54.999 -25.464 56.619 L -21.484 53.529 Z" /> <path fill="#EA4335" d="M -14.754 43.989 C -12.984 43.989 -11.404 44.599 -10.154 45.789 L -6.734 42.369 C -8.804 40.429 -11.514 39.239 -14.754 39.239 C -19.444 39.239 -23.494 41.939 -25.464 45.859 L -21.484 48.949 C -20.534 46.099 -17.884 43.989 -14.754 43.989 Z" /> </g> </svg> </button> <button onClick={() => handleSocialSignIn('facebook')} className="flex justify-center items-center py-2 px-4 border border-gray-300 dark:border-gray-600 rounded-md shadow-sm text-sm font-medium text-gray-700 dark:text-gray-300 bg-white dark:bg-gray-700 hover:bg-gray-50 dark:hover:bg-gray-600" > <Facebook className="h-5 w-5 text-blue-600" /> </button> </div> </div> <div className="text-center mt-6"> <p className="text-sm text-gray-600 dark:text-gray-400"> Don't have an account?{' '} <Link href="/auth/signup" className="text-blue-600 hover:text-blue-500"> Sign up </Link> </p> </div> </div> </div> ); }
```

# src/app/auth/error/page.tsx

```tsx
'use client'; import { useEffect, useState } from 'react'; import { useSearchParams } from 'next/navigation'; import Link from 'next/link'; import { AlertTriangle } from 'lucide-react'; export default function AuthErrorPage() { const searchParams = useSearchParams(); const [errorMessage, setErrorMessage] = useState<string>('An unknown error occurred'); const [errorDescription, setErrorDescription] = useState<string>(''); useEffect(() => { const error = searchParams.get('error'); if (error) { switch (error) { case 'Configuration': setErrorMessage('Server Configuration Error'); setErrorDescription('There is a problem with the server configuration. Please contact support.'); break; case 'AccessDenied': setErrorMessage('Access Denied'); setErrorDescription('You do not have access to this resource.'); break; case 'Verification': setErrorMessage('Verification Failed'); setErrorDescription('The verification token is invalid or has expired.'); break; case 'OAuthSignin': setErrorMessage('OAuth Sign In Error'); setErrorDescription('An error occurred during the OAuth sign-in process.'); break; case 'OAuthCallback': setErrorMessage('OAuth Callback Error'); setErrorDescription('An error occurred during the OAuth callback process.'); break; case 'OAuthCreateAccount': setErrorMessage('Account Creation Error'); setErrorDescription('An error occurred while creating your account with this OAuth provider.'); break; case 'EmailCreateAccount': setErrorMessage('Account Creation Error'); setErrorDescription('An error occurred while creating your account with this email.'); break; case 'Callback': setErrorMessage('Callback Error'); setErrorDescription('An error occurred during the authentication callback.'); break; case 'OAuthAccountNotLinked': setErrorMessage('Account Not Linked'); setErrorDescription('This email is already associated with another account. Please sign in using the original provider.'); break; case 'EmailSignin': setErrorMessage('Email Sign In Error'); setErrorDescription('An error occurred when sending the email for sign in.'); break; case 'CredentialsSignin': setErrorMessage('Invalid Credentials'); setErrorDescription('The credentials you provided are invalid or the account does not exist.'); break; case 'SessionRequired': setErrorMessage('Authentication Required'); setErrorDescription('You must be signed in to access this resource.'); break; default: setErrorMessage('Authentication Error'); setErrorDescription('An unknown error occurred during authentication.'); } } }, [searchParams]); return ( <div className="min-h-screen flex items-center justify-center bg-gray-50 dark:bg-gray-900 px-4"> <div className="max-w-md w-full space-y-8 bg-white dark:bg-gray-800 p-8 rounded-xl shadow-md"> <div className="flex flex-col items-center justify-center text-center"> <div className="bg-red-100 dark:bg-red-900/20 p-3 rounded-full"> <AlertTriangle className="h-10 w-10 text-red-600 dark:text-red-400" /> </div> <h1 className="mt-4 text-2xl font-bold text-gray-900 dark:text-white">{errorMessage}</h1> <p className="mt-2 text-gray-600 dark:text-gray-400">{errorDescription}</p> </div> <div className="flex flex-col space-y-4"> <Link href="/auth/signin" className="w-full flex justify-center py-2 px-4 border border-transparent rounded-md shadow-sm text-sm font-medium text-white bg-blue-600 hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500" > Back to Sign In </Link> <Link href="/" className="w-full flex justify-center py-2 px-4 border border-gray-300 dark:border-gray-700 rounded-md shadow-sm text-sm font-medium text-gray-700 dark:text-gray-300 bg-white dark:bg-gray-800 hover:bg-gray-50 dark:hover:bg-gray-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-gray-500" > Go to Homepage </Link> </div> </div> </div> ); }
```

# src/app/api/posts/route.ts

```ts
// src/app/api/posts/route.ts import { NextRequest, NextResponse } from 'next/server'; import { getServerSession } from 'next-auth/next'; import { postCreateSchema } from '@/lib/validations'; import prisma from '@/lib/db'; import { authOptions } from '@/lib/auth'; // GET /api/posts - Get all posts (paginated) export async function GET(request: NextRequest) { try { const { searchParams } = new URL(request.url); const page = parseInt(searchParams.get('page') || '1'); const limit = parseInt(searchParams.get('limit') || '10'); const skip = (page - 1) * limit; const posts = await prisma.post.findMany({ take: limit, skip, orderBy: { createdAt: 'desc', }, include: { author: { select: { id: true, username: true, handle: true, profileImage: true, }, }, _count: { select: { comments: true, likes: true, }, }, }, }); // Get total count for pagination const total = await prisma.post.count(); return NextResponse.json({ posts, pagination: { total, pages: Math.ceil(total / limit), page, limit, }, }); } catch (error) { console.error('Error fetching posts:', error); return NextResponse.json( { error: 'Internal server error' }, { status: 500 } ); } } // POST /api/posts - Create a new post export async function POST(request: NextRequest) { try { const session = await getServerSession(authOptions); if (!session?.user) { return NextResponse.json( { error: 'Unauthorized' }, { status: 401 } ); } const json = await request.json(); // Validate with Zod const result = postCreateSchema.safeParse(json); if (!result.success) { return NextResponse.json( { error: 'Invalid post data', issues: result.error.issues }, { status: 400 } ); } // Ensure the current user is the author if (result.data.authorId !== session.user.id) { return NextResponse.json( { error: 'Unauthorized: cannot create posts for other users' }, { status: 403 } ); } // Create post const post = await prisma.post.create({ data: { text: result.data.text, images: result.data.images, authorId: session.user.id, communityId: result.data.communityId, }, }); return NextResponse.json(post, { status: 201 }); } catch (error) { console.error('Error creating post:', error); return NextResponse.json( { error: 'Internal server error' }, { status: 500 } ); } }
```

# src/app/api/ads/route.ts

```ts
import { NextRequest, NextResponse } from 'next/server'; import prisma from '@/lib/db'; // GET /api/ads - Get active advertisements for the feed export async function GET(request: NextRequest) { try { const { searchParams } = new URL(request.url); const limit = parseInt(searchParams.get('limit') || '5'); // Get active ads, prioritized by priority field const ads = await prisma.advertisement.findMany({ where: { active: true, }, take: limit, orderBy: [ { priority: 'desc' }, { createdAt: 'desc' }, ], }); return NextResponse.json(ads); } catch (error) { console.error('Error fetching ads:', error); return NextResponse.json( { error: 'Internal server error' }, { status: 500 } ); } } // For admin use - Create a new advertisement export async function POST(request: NextRequest) { try { // In a real application, we would check for admin privileges here const json = await request.json(); const ad = await prisma.advertisement.create({ data: { title: json.title, content: json.content, imageUrl: json.imageUrl, link: json.link, active: json.active || true, priority: json.priority || 0, }, }); return NextResponse.json(ad, { status: 201 }); } catch (error) { console.error('Error creating ad:', error); return NextResponse.json( { error: 'Internal server error' }, { status: 500 } ); } }
```

# src/app/profile/[handle]/following/page.tsx

```tsx
'use client'; import { useState, useEffect } from 'react'; import { useParams } from 'next/navigation'; import { useSession } from 'next-auth/react'; import Image from 'next/image'; import Link from 'next/link'; import { Loader2, ArrowLeft } from 'lucide-react'; import FollowButton from '@/components/user/FollowButton'; interface User { id: string; username: string; handle: string; profileImage: string | null; bio: string | null; } export default function FollowingPage() { const { handle } = useParams(); const { data: session } = useSession(); const [user, setUser] = useState<User | null>(null); const [following, setFollowing] = useState<User[]>([]); const [loading, setLoading] = useState(true); const [error, setError] = useState<string | null>(null); useEffect(() => { const fetchUser = async () => { try { const response = await fetch(`/api/users/by-handle/${handle}`); if (!response.ok) { throw new Error('User not found'); } return await response.json(); } catch (err) { console.error('Error fetching user:', err); setError('User not found'); return null; } }; const fetchFollowing = async (userId: string) => { try { const response = await fetch(`/api/users/${userId}/following`); if (!response.ok) { throw new Error('Failed to load following'); } return await response.json(); } catch (err) { console.error('Error fetching following:', err); setError('Failed to load following'); return []; } }; const loadData = async () => { setLoading(true); const userData = await fetchUser(); if (userData) { setUser(userData); const followingData = await fetchFollowing(userData.id); setFollowing(followingData); } setLoading(false); }; loadData(); }, [handle]); if (loading) { return ( <div className="flex justify-center items-center h-64"> <Loader2 className="h-8 w-8 animate-spin text-blue-500" /> </div> ); } if (error || !user) { return ( <div className="max-w-2xl mx-auto p-4"> <div className="bg-red-100 dark:bg-red-900 p-4 rounded-lg text-red-600 dark:text-red-200"> {error || 'An error occurred'} </div> </div> ); } return ( <div className="max-w-2xl mx-auto p-4"> <div className="flex items-center mb-6"> <Link href={`/profile/${handle}`} className="mr-4"> <ArrowLeft className="h-5 w-5" /> </Link> <div> <h1 className="text-xl font-bold">Following</h1> <p className="text-gray-600 dark:text-gray-400">People followed by {user.username}</p> </div> </div> {following.length === 0 ? ( <div className="text-center py-8 text-gray-500 dark:text-gray-400"> {user.username} isn't following anyone yet. </div> ) : ( <div className="divide-y divide-gray-200 dark:divide-gray-700"> {following.map((followedUser) => ( <div key={followedUser.id} className="py-4 flex items-center justify-between"> <Link href={`/profile/${followedUser.handle}`} className="flex items-center"> <Image src={followedUser.profileImage || '/default-avatar.png'} alt={followedUser.username} width={48} height={48} className="rounded-full" /> <div className="ml-3"> <div className="font-medium">{followedUser.username}</div> <div className="text-gray-500 dark:text-gray-400">{followedUser.handle}</div> </div> </Link> {session?.user.id !== followedUser.id && ( <FollowButton userId={followedUser.id} /> )} </div> ))} </div> )} </div> ); }
```

# src/app/profile/[handle]/followers/page.tsx

```tsx
'use client'; import { useState, useEffect } from 'react'; import { useParams } from 'next/navigation'; import { useSession } from 'next-auth/react'; import Image from 'next/image'; import Link from 'next/link'; import { Loader2, ArrowLeft } from 'lucide-react'; import FollowButton from '@/components/user/FollowButton'; interface User { id: string; username: string; handle: string; profileImage: string | null; bio: string | null; } export default function FollowersPage() { const { handle } = useParams(); const { data: session } = useSession(); const [user, setUser] = useState<User | null>(null); const [followers, setFollowers] = useState<User[]>([]); const [loading, setLoading] = useState(true); const [error, setError] = useState<string | null>(null); useEffect(() => { const fetchUser = async () => { try { const response = await fetch(`/api/users/by-handle/${handle}`); if (!response.ok) { throw new Error('User not found'); } return await response.json(); } catch (err) { console.error('Error fetching user:', err); setError('User not found'); return null; } }; const fetchFollowers = async (userId: string) => { try { const response = await fetch(`/api/users/${userId}/followers`); if (!response.ok) { throw new Error('Failed to load followers'); } return await response.json(); } catch (err) { console.error('Error fetching followers:', err); setError('Failed to load followers'); return []; } }; const loadData = async () => { setLoading(true); const userData = await fetchUser(); if (userData) { setUser(userData); const followersData = await fetchFollowers(userData.id); setFollowers(followersData); } setLoading(false); }; loadData(); }, [handle]); if (loading) { return ( <div className="flex justify-center items-center h-64"> <Loader2 className="h-8 w-8 animate-spin text-blue-500" /> </div> ); } if (error || !user) { return ( <div className="max-w-2xl mx-auto p-4"> <div className="bg-red-100 dark:bg-red-900 p-4 rounded-lg text-red-600 dark:text-red-200"> {error || 'An error occurred'} </div> </div> ); } return ( <div className="max-w-2xl mx-auto p-4"> <div className="flex items-center mb-6"> <Link href={`/profile/${handle}`} className="mr-4"> <ArrowLeft className="h-5 w-5" /> </Link> <div> <h1 className="text-xl font-bold">Followers</h1> <p className="text-gray-600 dark:text-gray-400">People following {user.username}</p> </div> </div> {followers.length === 0 ? ( <div className="text-center py-8 text-gray-500 dark:text-gray-400"> {user.username} doesn't have any followers yet. </div> ) : ( <div className="divide-y divide-gray-200 dark:divide-gray-700"> {followers.map((follower) => ( <div key={follower.id} className="py-4 flex items-center justify-between"> <Link href={`/profile/${follower.handle}`} className="flex items-center"> <Image src={follower.profileImage || '/default-avatar.png'} alt={follower.username} width={48} height={48} className="rounded-full" /> <div className="ml-3"> <div className="font-medium">{follower.username}</div> <div className="text-gray-500 dark:text-gray-400">{follower.handle}</div> </div> </Link> {session?.user.id !== follower.id && ( <FollowButton userId={follower.id} /> )} </div> ))} </div> )} </div> ); }
```

# src/app/api/posts/following/route.ts

```ts
import { NextRequest, NextResponse } from 'next/server'; import { getServerSession } from 'next-auth/next'; import prisma from '@/lib/db'; import { authOptions } from '@/lib/auth'; // GET /api/posts/following - Get posts from users the current user follows export async function GET(request: NextRequest) { try { const session = await getServerSession(authOptions); if (!session?.user) { return NextResponse.json( { error: 'Unauthorized' }, { status: 401 } ); } const { searchParams } = new URL(request.url); const page = parseInt(searchParams.get('page') || '1'); const limit = parseInt(searchParams.get('limit') || '10'); const skip = (page - 1) * limit; // Get users they follow const following = await prisma.follow.findMany({ where: { followerId: session.user.id, }, select: { followingId: true, }, }); const followingIds = following.map(f => f.followingId); // If user doesn't follow anyone, return empty array if (followingIds.length === 0) { return NextResponse.json([]); } // Get posts from followed users const posts = await prisma.post.findMany({ where: { authorId: { in: followingIds }, }, take: limit, skip, orderBy: { createdAt: 'desc', // Most recent first }, include: { author: { select: { id: true, username: true, handle: true, profileImage: true, }, }, _count: { select: { comments: true, likes: true, }, }, }, }); // Check if the user has liked each post const postsWithLikeStatus = await Promise.all( posts.map(async (post) => { const like = await prisma.like.findUnique({ where: { postId_userId: { postId: post.id, userId: session.user.id, }, }, }); const bookmark = await prisma.bookmark.findUnique({ where: { postId_userId: { postId: post.id, userId: session.user.id, }, }, }); return { ...post, liked: !!like, bookmarked: !!bookmark, }; }) ); // Track impressions for these posts await Promise.all( posts.map(post => prisma.post.update({ where: { id: post.id }, data: { impressions: post.impressions + 1 }, }) ) ); return NextResponse.json(postsWithLikeStatus); } catch (error) { console.error('Error fetching following feed:', error); return NextResponse.json( { error: 'Internal server error' }, { status: 500 } ); } }
```

# src/app/api/posts/for-you/route.ts

```ts
import { NextRequest, NextResponse } from 'next/server'; import { getServerSession } from 'next-auth/next'; import prisma from '@/lib/db'; import { authOptions } from '@/lib/auth'; // GET /api/posts/for-you - Get curated posts for the user export async function GET(request: NextRequest) { try { const session = await getServerSession(authOptions); if (!session?.user) { return NextResponse.json( { error: 'Unauthorized' }, { status: 401 } ); } const { searchParams } = new URL(request.url); const page = parseInt(searchParams.get('page') || '1'); const limit = parseInt(searchParams.get('limit') || '10'); const skip = (page - 1) * limit; // Get user's interests (communities they're part of) const userCommunities = await prisma.membership.findMany({ where: { userId: session.user.id, }, select: { communityId: true, }, }); const communityIds = userCommunities.map(c => c.communityId); // Get users they follow const following = await prisma.follow.findMany({ where: { followerId: session.user.id, }, select: { followingId: true, }, }); const followingIds = following.map(f => f.followingId); // Curate posts based on: // 1. Posts from communities they're part of // 2. Posts from users they follow // 3. Popular posts (high engagement) // 4. Recent posts const posts = await prisma.post.findMany({ where: { OR: [ { communityId: { in: communityIds.length ? communityIds : undefined } }, { authorId: { in: followingIds.length ? followingIds : undefined } }, { impressions: { gt: 50 } }, // Popular posts ], // Exclude posts by blocked users (if implemented) }, take: limit, skip, orderBy: [ { impressions: 'desc' }, // Higher impressions first { createdAt: 'desc' }, // Then recent posts ], include: { author: { select: { id: true, username: true, handle: true, profileImage: true, }, }, _count: { select: { comments: true, likes: true, }, }, }, }); // Check if the user has liked each post const postsWithLikeStatus = await Promise.all( posts.map(async (post) => { const like = await prisma.like.findUnique({ where: { postId_userId: { postId: post.id, userId: session.user.id, }, }, }); const bookmark = await prisma.bookmark.findUnique({ where: { postId_userId: { postId: post.id, userId: session.user.id, }, }, }); return { ...post, liked: !!like, bookmarked: !!bookmark, }; }) ); // Track impressions for these posts await Promise.all( posts.map(post => prisma.post.update({ where: { id: post.id }, data: { impressions: post.impressions + 1 }, }) ) ); return NextResponse.json(postsWithLikeStatus); } catch (error) { console.error('Error fetching for-you feed:', error); return NextResponse.json( { error: 'Internal server error' }, { status: 500 } ); } }
```

# src/app/api/auth/error/route.ts

```ts
import { NextRequest, NextResponse } from 'next/server'; export async function GET(request: NextRequest) { const { searchParams } = new URL(request.url); const error = searchParams.get('error'); // Return the error information as JSON return NextResponse.json({ error: error || 'Unknown error', description: getErrorDescription(error || '') }); } // Helper function to provide more descriptive error messages function getErrorDescription(error: string): string { switch (error) { case 'Configuration': return 'There is a problem with the server configuration.'; case 'AccessDenied': return 'You do not have access to this resource.'; case 'Verification': return 'The verification token is invalid or has expired.'; case 'OAuthSignin': return 'Error in OAuth sign-in process.'; case 'OAuthCallback': return 'Error in OAuth callback.'; case 'OAuthCreateAccount': return 'Error creating OAuth account.'; case 'EmailCreateAccount': return 'Error creating email account.'; case 'Callback': return 'Error in callback handler.'; case 'OAuthAccountNotLinked': return 'Email already in use with a different provider.'; case 'EmailSignin': return 'Error sending email for sign-in.'; case 'CredentialsSignin': return 'Invalid credentials.'; case 'SessionRequired': return 'You must be signed in to access this resource.'; default: return 'An unknown error occurred.'; } }
```

# src/app/api/auth/[...nextauth]/route.ts

```ts
import NextAuth from 'next-auth'; import { authOptions } from '@/lib/auth'; const handler = NextAuth(authOptions); export { handler as GET, handler as POST };
```

# src/app/api/posts/[id]/like/route.ts

```ts
import { NextRequest, NextResponse } from 'next/server'; import { getServerSession } from 'next-auth/next'; import prisma from '@/lib/db'; import { authOptions } from '@/lib/auth'; // POST /api/posts/[id]/like - Like a post export async function POST( request: NextRequest, { params }: { params: { id: string } } ) { try { const session = await getServerSession(authOptions); if (!session?.user) { return NextResponse.json( { error: 'Unauthorized' }, { status: 401 } ); } const postId = params.id; // Check if post exists const post = await prisma.post.findUnique({ where: { id: postId }, }); if (!post) { return NextResponse.json( { error: 'Post not found' }, { status: 404 } ); } // Check if already liked const existingLike = await prisma.like.findUnique({ where: { postId_userId: { postId, userId: session.user.id, }, }, }); if (existingLike) { return NextResponse.json( { error: 'Post already liked' }, { status: 400 } ); } // Create like const like = await prisma.like.create({ data: { postId, userId: session.user.id, }, }); // Create notification for post author (if not self-like) if (post.authorId !== session.user.id) { await prisma.notification.create({ data: { type: 'like', userId: post.authorId, sourceId: session.user.id, postId, }, }); } return NextResponse.json(like, { status: 201 }); } catch (error) { console.error('Error liking post:', error); return NextResponse.json( { error: 'Internal server error' }, { status: 500 } ); } } // DELETE /api/posts/[id]/like - Unlike a post export async function DELETE( request: NextRequest, { params }: { params: { id: string } } ) { try { const session = await getServerSession(authOptions); if (!session?.user) { return NextResponse.json( { error: 'Unauthorized' }, { status: 401 } ); } const postId = params.id; // Check if post exists const post = await prisma.post.findUnique({ where: { id: postId }, }); if (!post) { return NextResponse.json( { error: 'Post not found' }, { status: 404 } ); } // Find and delete the like const like = await prisma.like.deleteMany({ where: { postId, userId: session.user.id, }, }); if (like.count === 0) { return NextResponse.json( { error: 'Like not found' }, { status: 404 } ); } return NextResponse.json({ success: true }); } catch (error) { console.error('Error unliking post:', error); return NextResponse.json( { error: 'Internal server error' }, { status: 500 } ); } }
```

# src/app/api/users/by-handle/[handle]/route.ts

```ts
// src/app/api/users/by-handle/[handle]/route.ts import { NextResponse } from 'next/server'; import prisma from '@/lib/db'; export async function GET( request: Request, context: { params: Promise<{ handle: string }> } ) { // Await the params object before destructuring const { handle: rawHandle } = await context.params; if (!rawHandle) { return NextResponse.json( { error: 'Handle parameter missing' }, { status: 400 } ); } // Strip leading '@' if present const handle = rawHandle.startsWith('@') ? rawHandle.substring(1) : rawHandle; try { const user = await prisma.user.findFirst({ where: { handle }, select: { id: true, username: true, handle: true, profileImage: true, bio: true, createdAt: true, }, }); if (!user) { return NextResponse.json({ error: 'User not found' }, { status: 404 }); } return NextResponse.json(user); } catch (err) { console.error('Error fetching user by handle:', err); return NextResponse.json({ error: 'Server error' }, { status: 500 }); } }
```

# src/app/api/users/[id]/posts/route.ts

```ts
import { NextRequest, NextResponse } from 'next/server'; import prisma from '@/lib/db'; // GET /api/users/[id]/posts - Get posts by a specific user export async function GET( request: NextRequest, { params }: { params: { id: string } } ) { try { const userId = params.id; const { searchParams } = new URL(request.url); const page = parseInt(searchParams.get('page') || '1'); const limit = parseInt(searchParams.get('limit') || '10'); const skip = (page - 1) * limit; // Check if user exists const user = await prisma.user.findUnique({ where: { id: userId }, }); if (!user) { return NextResponse.json( { error: 'User not found' }, { status: 404 } ); } // Get user's posts const posts = await prisma.post.findMany({ where: { authorId: userId }, include: { author: { select: { id: true, username: true, handle: true, profileImage: true, }, }, _count: { select: { comments: true, likes: true, }, }, }, orderBy: { createdAt: 'desc', // Most recent posts first }, skip, take: limit, }); return NextResponse.json(posts); } catch (error) { console.error('Error getting user posts:', error); return NextResponse.json( { error: 'Internal server error' }, { status: 500 } ); } }
```

# src/app/api/users/[id]/following/route.ts

```ts
import { NextRequest, NextResponse } from 'next/server'; import prisma from '@/lib/db'; // GET /api/users/[id]/following - Get users followed by the specified user export async function GET( request: NextRequest, { params }: { params: { id: string } } ) { try { const userId = params.id; const { searchParams } = new URL(request.url); const page = parseInt(searchParams.get('page') || '1'); const limit = parseInt(searchParams.get('limit') || '20'); const skip = (page - 1) * limit; // Check if user exists const user = await prisma.user.findUnique({ where: { id: userId }, }); if (!user) { return NextResponse.json( { error: 'User not found' }, { status: 404 } ); } // Get users that this user follows const follows = await prisma.follow.findMany({ where: { followerId: userId }, include: { following: { select: { id: true, username: true, handle: true, profileImage: true, bio: true, }, }, }, skip, take: limit, orderBy: { createdAt: 'desc', // Most recently followed users first }, }); // Extract following user details const following = follows.map(follow => follow.following); return NextResponse.json(following); } catch (error) { console.error('Error getting following:', error); return NextResponse.json( { error: 'Internal server error' }, { status: 500 } ); } }
```

# src/app/api/users/[id]/follow-counts/route.ts

```ts
// src/app/api/users/[id]/follow-counts/route.ts import { NextResponse } from 'next/server'; import prisma from '@/lib/db'; export async function GET( req: Request, { params }: { params: { id: string } } ) { try { // Await params before accessing its properties const { id: userId } = await params; if (!userId) { return NextResponse.json( { error: 'User ID parameter is missing' }, { status: 400 } ); } // Verify user exists const user = await prisma.user.findUnique({ where: { id: userId } }); if (!user) { return NextResponse.json( { error: 'User not found' }, { status: 404 } ); } // Count followers const followersCount = await prisma.follow.count({ where: { followingId: userId }, }); const followingCount = await prisma.follow.count({ where: { followerId: userId }, }); return NextResponse.json({ followers: followersCount, following: followingCount }); } catch (error) { console.error('Error fetching follower count:', error); return NextResponse.json( { error: 'Failed to fetch follower count' }, { status: 500 } ); } }
```

# src/app/api/users/[id]/followers/route.ts

```ts
// src/app/api/users/[id]/followers/route.ts import { NextResponse } from 'next/server'; import prisma from '@/lib/db'; export async function GET( req: Request, { params }: { params: { id: string } } ) { try { const userId = params.id; if (!userId) { return NextResponse.json( { error: 'User ID parameter is missing' }, { status: 400 } ); } // Fetch follower records const follows = await prisma.follow.findMany({ where: { followingId: userId }, include: { follower: { select: { id: true, username: true, handle: true, profileImage: true, bio: true, }, }, }, }); // Return the array directly const followersArray = follows.map((f) => f.follower); return NextResponse.json(followersArray); } catch (error) { console.error('Error fetching followers:', error); return NextResponse.json( { error: 'Failed to fetch followers' }, { status: 500 } ); } }
```

# src/app/api/users/[id]/follow/route.ts

```ts
import { NextRequest, NextResponse } from 'next/server'; import { getServerSession } from 'next-auth/next'; import prisma from '@/lib/db'; import { authOptions } from '@/lib/auth'; // POST /api/users/[id]/follow - Follow a user export async function POST( request: NextRequest, { params }: { params: { id: string } } ) { try { const session = await getServerSession(authOptions); if (!session?.user) { return NextResponse.json( { error: 'Unauthorized' }, { status: 401 } ); } const targetUserId = params.id; const currentUserId = session.user.id; // Can't follow yourself if (targetUserId === currentUserId) { return NextResponse.json( { error: 'You cannot follow yourself' }, { status: 400 } ); } // Check if target user exists const targetUser = await prisma.user.findUnique({ where: { id: targetUserId }, }); if (!targetUser) { return NextResponse.json( { error: 'User not found' }, { status: 404 } ); } // Check if already following const existingFollow = await prisma.follow.findUnique({ where: { followerId_followingId: { followerId: currentUserId, followingId: targetUserId, }, }, }); if (existingFollow) { return NextResponse.json( { error: 'Already following this user' }, { status: 400 } ); } // Create follow relationship const follow = await prisma.follow.create({ data: { followerId: currentUserId, followingId: targetUserId, }, }); // Create notification for the target user await prisma.notification.create({ data: { type: 'follow', userId: targetUserId, // Who receives the notification sourceId: currentUserId, // Who triggered the notification }, }); // Update user metrics if they exist const userMetrics = await prisma.userMetrics.findUnique({ where: { userId: targetUserId }, }); if (userMetrics) { await prisma.userMetrics.update({ where: { userId: targetUserId }, data: { followersGrowth: userMetrics.followersGrowth + 1, }, }); } else { // Create metrics if they don't exist await prisma.userMetrics.create({ data: { userId: targetUserId, followersGrowth: 1, }, }); } return NextResponse.json(follow, { status: 201 }); } catch (error) { console.error('Error following user:', error); return NextResponse.json( { error: 'Internal server error' }, { status: 500 } ); } } // DELETE /api/users/[id]/follow - Unfollow a user export async function DELETE( request: NextRequest, { params }: { params: { id: string } } ) { try { const session = await getServerSession(authOptions); if (!session?.user) { return NextResponse.json( { error: 'Unauthorized' }, { status: 401 } ); } const targetUserId = params.id; const currentUserId = session.user.id; // Check if the relationship exists const existingFollow = await prisma.follow.findUnique({ where: { followerId_followingId: { followerId: currentUserId, followingId: targetUserId, }, }, }); if (!existingFollow) { return NextResponse.json( { error: 'You are not following this user' }, { status: 404 } ); } // Delete the follow relationship await prisma.follow.delete({ where: { followerId_followingId: { followerId: currentUserId, followingId: targetUserId, }, }, }); // Update user metrics if they exist const userMetrics = await prisma.userMetrics.findUnique({ where: { userId: targetUserId }, }); if (userMetrics && userMetrics.followersGrowth > 0) { await prisma.userMetrics.update({ where: { userId: targetUserId }, data: { followersGrowth: userMetrics.followersGrowth - 1, }, }); } return NextResponse.json({ success: true }); } catch (error) { console.error('Error unfollowing user:', error); return NextResponse.json( { error: 'Internal server error' }, { status: 500 } ); } }
```

# src/app/api/users/[id]/follows/[targetId]/route.ts

```ts
import { NextRequest, NextResponse } from 'next/server'; import { getServerSession } from 'next-auth/next'; import prisma from '@/lib/db'; import { authOptions } from '@/lib/auth'; // GET /api/users/[id]/follows/[targetId] - Check if user follows target user export async function GET( request: NextRequest, { params }: { params: { id: string; targetId: string } } ) { try { const session = await getServerSession(authOptions); const { id, targetId } = params; // If checking if current user follows someone, verify authentication if (id === 'me') { if (!session?.user) { return NextResponse.json( { error: 'Unauthorized' }, { status: 401 } ); } // Use the current user's ID const userId = session.user.id; // Check if the follow relationship exists const follow = await prisma.follow.findUnique({ where: { followerId_followingId: { followerId: userId, followingId: targetId, }, }, }); return NextResponse.json({ following: !!follow }); } else { // If checking if any user follows another const follow = await prisma.follow.findUnique({ where: { followerId_followingId: { followerId: id, followingId: targetId, }, }, }); return NextResponse.json({ following: !!follow }); } } catch (error) { console.error('Error checking follow status:', error); return NextResponse.json( { error: 'Internal server error' }, { status: 500 } ); } }
```

